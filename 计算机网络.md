# 1.TCP三次握手四次挥手的过程

- 握手的目的

  > TCP是面向连接的协议，握手的目的是检查对方可以进行通信。

- 三次握手

   > TCP会在通信之前，利用TCP首部发送一个SYN包请求建立连接，服务器端收到SYN包之后，会发送SYN\ACK包给客户端，客户端收到之后，会发送ACK包给服务器端。

**三次握手比四次挥手少一次通信的原因，服务端在收到客户端SYN包之后，会发送ACK包给客户端，并发送SYN包，三次握手把服务器发送的SYN和ACK一起发送了。**

- 四次挥手
  
  > 客户端会发送FIN包给服务器端请求断开连接，服务器端会返回ACK包给客户端，但这时服务器端可能还有工作没有处理完，所以需要等待一会，再发送FIN包给客户端，客户端收到之后会发送ACK包给服务器端。

**从这个过程可以看到，TCP发送包的过程中，接收端必定会发送ACK包给发送端。**

# 2.四次挥手如果客户端没收到服务器返回的close会一直等吗（不会），为什么

> TCP具有超时重传机制，当经过重发超时之后，客户端会重发FIN数据包，如果一直没有收到，会把重发超时按照2倍、4倍的指数规律进行重置，一直到重发指定次数，客户端认为服务器端出现了问题，强制关闭连接。

# 3.TCP是怎么保证可靠连接的
> TCP利用序列号（Seq）保证可靠连接，因为可靠连接要求识别数据是否已经接收，TCP会为每一个字节编一个号，这个就是Seq，接收端在收到数据之后，查询TCP首部中的序列号（Seq）以及数据长度，把自己下一步要接收的TCP数据段的第一个字节的序列号（Seq）放在确认应答的TCP首部发送给发送端。
>
> **Seq是TCP为每一个字节编的号，初始Seq由一个32位的时钟产生。**

**每个字节都有一个Seq Number，Seq Number存在于TCP首部，接收端下一步要接收的包的第一个字节的Seq Number放在ACK包的TCP首部的ACK Number发送给发送方。**

Seq Number是所有数据中的第几个字节，Seq Number为1表示是第一个字节。

Ack Number表示接收端期望收到的下一个TCP数据包的第一个字节的Seq Number。



# 4.为什么需要三次握手

> 《计算机网络》中有提到，三次握手是为了避免某一个旧TCP连接的SYN包在网络中滞留了很久到达了服务端，这时服务端会向发送端发送ACK包，如果不需要客户端回复ACK包的话，服务器端就会以为TCP连接已经建立，会一直等待客户端发送数据，但是实际上客户端不会向服务器端发送数据，这就导致了服务器端资源的浪费。
>
> 本质在RFC793有说明，是因为TCP为了保证可靠连接使用了Seq，同时TCP可以使用最初的Seq确认是否是相同的连接，但初始的Seq是发送端自己凭借时钟生成的，所以为了保证可靠通信，TCP在接收到一个初始Seq（SYN包的TCP首部包含初始Seq）就会向客户端请求确认，只有客户端返回了ACK包，才能保证可靠连接。

# 5.为什么需要四次挥手
> 因为四次挥手过程中，客户端向服务器端发送FIN报文，服务器端在收到这个FIN报文，可能还有数据没有发完，所以不能把ACK和FIN报文合并发送，所以只能先向发送方发送ACK包，表示确认收到FIN包，等到数据处理完成，再发送FIN包，等待收到ACK包之后，服务器端就认为TCP连接已经关闭，进入CLOSE状态，客户端在等待一段时间之后自动进入CLOSE状态，至此TCP连接关闭。



# 6.HTTPS过程
1.HTTPS是加了SSL协议的HTTP，HTTPS需要先和SSL协议，SSL协议再和TCP协议通信。
2.HTTPS采用对称加密和非对称加密结合的方法，因为单一的对称加密不能保证密钥传输安全性，单一非对称加密计算消耗资源过大。
3.HTTPS会在传输密钥阶段使用非对称加密，在通信阶段使用对称加密。
4.HTTPS的过程
 - 服务器人员首先向CA申请公钥，CA在验证了申请者身份之后，会为申请者分配公钥并用自己的私钥对公钥做数字签名，然后把经过数字签名的公钥放到数字证书发给服务器端，数字证书中同样包含未进行非对称加密的公钥，这主要是为了客户端验证公钥的数字签名。
 - 客户端向服务器端请求通信时，服务器端会把数字证书发给客户端，客户端会利用CA的公钥对数字证书中的公钥数字签名做验证，如果验证通过，说明这是真实的服务器端公钥。
 - 客户端会使用这个公钥对对称加密要使用的密钥进行加密处理，并发送给服务器端。
 - 服务器端收到后会使用自己的私钥进行解密。
 - 开始通信，使用对称加密。


# 7.有哪些熟悉的HTTP状态码
> - 2XX状态码表示正常处理
>
>   1. 200状态码表示客户端的请求被正常处理了。
>
>   2. 204状态码，表示请求已经处理，但没有需要返回的报文主体部分。
>
>   3. 206状态码，表示范围请求已经正常处理。
> - 3XX状态码表示重定向
>   1. 301状态码，表示永久性重定向，当前客户端访问的资源已经被永久分配了新的URI，下次访问请使用新URI，会更新浏览器中的书签引用。
>   2. 302状态码，表示临时性重定向，当前客户端访问的资源临时被分配了新的URI，本次访问请使用新URI，但以后访问还是使用旧URI。
>   3. 304状态码，表示资源没有发生更改。
>   4. 307状态码，含义和302状态码一样，但因为302状态各浏览器都不遵循不能把POST改成GET的规定，所以重新定义的新状态码，对于307，所有浏览器都不会把POST改成GET。
> - 4XX状态码表示客户端错误
>   1. 400状态码，表示客户端请求报文中有语法错误。
>   2. 401状态码，表示需要身份验证。
>   3. 403状态码，表示客户端请求的资源不允许访问。
>   4. 404状态码，表示没有找到资源。
> - 5XX状态码表示服务器错误
>   1. 500状态码，表示服务器无法处理请求。
>   2. 503状态码，表示服务器正在停机维护或正超负载工作，无法响应请求。
>

# 8.OSI七层网络模型和TCP/IP五层网络模型

> - OSI七层网络模型
>   - OSI七层网络模型，从高到低是
>   - 应用层，作用是为应用程序提供服务。
>   - 表示层，数据格式转化、数据加密。
>   - 会话层，建立、管理和维护会话。
>   - 传输层，建立、管理和维护连接。
>   - 网络层，IP选址和路由选择。
>   - 数据链路层，提供链路管理。
>   - 物理层，通信所需的物理设施。
> - TCP/IP五层网络模型
>   - TCP/IP五层网络模型，从高到低是
>   - 应用层
>   - 传输层
>   - 网络层
>   - 数据链路层
>   - 物理层

# 9.TCP数据分片

> 因为TCP数据段需要在从发送端发给接收端，这样要求双方都需要有能力对TCP段进行处理，这就使得可能很大的TCP数据段需要切分。
>
> 在TCP握手的前2次握手中，TCP首部中会有MSS告知对方自己能接受的最大消息长度，实际通信所采用的MSS（最大消息长度）会采用较小的一个。
>
> **在TCP三次握手的时候完成。**

# 10.TCP滑动窗口

> 因为发送端在发送一个TCP段之后需要等待接收端的确认应答才能继续发送下一个数据段，这样就降低了通信性能，因此TCP引入了窗口的概念，窗口的大小是发送端一次能发送的TCP数据段的个数，如，窗口大小是3，发送端就可以连续发送3个TCP数据段，再等待接收端的确认应答。
>
> 如果发送端接受到一个确认应答，就会把窗口滑动到确认应答中的Seq位置。

# 11.窗口控制与重发机制

> 在进行滑动窗口的时候，如果发生丢包，发送端还是需要进行重发。
>
> - 触发重发机制的2种情况
>   - 接收端接收了TCP数据段，但是确认应答丢失。
>   - 接收端没有接收到TCP数据段。
>
> 1. **在第一种情况下**，发送端可以通过接收到后续确认应答来确定前面的一个TCP数据段已经被收到了，如，窗口的大小是3，如果发送端没有接收到第一个TCP数据段对应的确认应答，但是接收到了第二个TCP数据段对应的确认应答，这就说明第一个TCP数据段已经收到了，就不需要重发。
> 2. **在第二种情况下**，如果是某个TCP数据段丢失，那么接收端会会一直向发送端发送它想要接受的TCP数据段的第一个字节对应的Seq，如果发送端连续收到3次相同的确认应答，那么就会进行重发。

# 12.强缓存和协商缓存

> 强缓存和协商缓存是浏览器缓存策略，目的是为了降低请求时间。
>
> 强缓存是给资源设置一个过期时间，如果资源没有过期，浏览器就会使用强缓存，不会向服务器发送请求（浏览器直接从本地硬盘或内存中读取缓存，并且返回码将是200，但是返回码后会跟一个from memory cache）。
>
> 强缓存可以通过响应报文的cache-control设置，cache-control : max-age = 604800，表示这个资源的有效期限是604800秒。在HTTP/1.0的情况下，cache-control会被忽略，这时候需要用到Expires响应头，使用Expires: Wed, 04 Jul 2021 08:26:05 GMT来设置资源过期时间，超过这个时间之后，资源就过期了。**在Expires和cache-control同时存在的时候，cache-control优先级更高。**
>
> - cache-control: max-age=xxx, public
>   - 表示客户端和代理服务器都可以缓存该资源
>   - 如果客户端在xxx秒有效期内请求该资源，那么浏览器将直接从本地硬盘或内存中读取。但如果客户端刷新页面，浏览器将向服务器请求资源。
> - cache-control: max-age=xxx, private
>   - 表示只有客户端可以缓存资源，代理服务器不能缓存。
>   - 如果客户端在xxx秒内再次请求该资源，那么浏览器直接从本地存储中返回。
> - cache-control: max-age=xxx, immutable
>   - 如果客户端在xxx秒内再次请求该资源，那么浏览器直接从本地存储中返回。
>   - 即使用户刷新页面，浏览器也不会向源服务器发送请求。
> - cache-control: no-cache
>   - 不进行强缓存，直接进入协商缓存阶段。
>   - 一旦客户端重新请求资源，浏览器都必须向源服务器发送请求确认资源的有效性，也就是跳过强缓存，直接进行协商缓存。
> - cache-control: no-store
>   - 不采取缓存策略，也就是跳过强缓存和协商缓存，每次都请求资源。
>
> 当浏览器想要请求一个资源，并且发现这个资源的有效期已经到期，那么就会触发协商缓存，浏览器会将上次资源的响应头中取出E-tag和last-modified字段，并把E-tag放入请求头If-None-Match，把last-modified放入If-Modified-Since请求头，如果服务器返回304 Not Modified，那么浏览器就会使用缓存，如果服务器返回200 OK，那么浏览器就会使用服务器返回的资源。
>
> - 为什么需要e-tag和last-modefied配合使用
>   1. 有些资源可能会周期性发生修改，但内容并不改变，这个过程只改动了last-modified而没有改变e-tag，这样可以避免浏览器不必要的请求资源。
>   2. 某些文件修改的过于频繁，甚至是在秒以下级别的，但是last-modified只能精确到秒，因此需要e-tag。
> - 设置强缓存和协商缓存的方法
>   - node.s
>     - res.setHeader('Cache-Control': 'max-age=10000')

# 13.SSL握手的过程

> SSL过程有4次握手，来建立SSL连接，保证HTTP连接的安全性。
>
> 1. 第一次握手
>    - 客户端发送Client Hello，以及客户端支持的SSL版本，客户端支持的加密算法和密钥长度，包括一串客户端随机数（client random）。
> 2. 第二次握手
>    - 服务器端回复Sever Hello，以及从客户端支持的加密算法和密钥长度中筛选出来的加密算法和密钥长度，包括服务器随机数（server random）。
>    - 服务器发送Certificate报文，报文中包含公钥证书。
>    - 服务端发送Server Hello done报文。
> 3. 第三次握手
>    - 客户端发送Client Key Exchange作为回应，其中包含一个随机密码串，这个密码串已经使用公钥加密。
>    - 客户端发送Change Cipher Spec报文，这个报文会提示服务器端之后的通信使用刚刚发送的密码串加密。
>    - 客户端发送Finished报文，报文中包含本次握手的整体校验值，如果服务器端可以正确解密，那么握手成功。
> 4. 第四次握手
>    - 服务器端发送Change Cipher Spec报文。
>    - 服务器端发送Finished报文。

# 14.DNS域名解析的过程

> DNS域名解析是指由于IP地址并不好记，所以为了方便记忆开发出了方便人记忆的域名系统，但是因为计算机需要IP地址，所以在浏览器收到对一个域名的访问的时候，会先进行DNS查询，把域名转换为对应IP地址。
>
> **DNS协议位于应用层。**
>
> 1. 首先浏览器会在操作系统的hosts文件中查找，是否有缓存的域名和IP地址的映射。
> 2. 如果本地没有找到，那么会去向本地DNS服务器进行查询（本地DNS服务器一般由网络运营商提供），一般百分之八十的DNS请求都会在本地域名服务器找到对应IP的缓存。
> 3. 如果本地域名服务器也没有找到，那么本地域名服务器就会去向根域名服务器进行查询，根域名服务器不会直接返回域名的对应IP地址，根域名服务器会返回对应顶级域名服务器的地址。
> 4. 本地域名服务器再去对应顶级域名服务器查找，顶级域名服务器也不会直接返回域名对应的IP，顶级域名服务器会返回该域名的注册域名服务器的地址。
> 5. 本地域名服务器再去向该域名的注册域名服务器地址进行查询，然后会收到对应的IP地址。

# 15.DNS基于哪种协议

> DNS主要基于UDP协议。
>
> - 因为UDP协议是面向无连接的协议，不需要经过TCP三次握手，这样网络性能更高，且服务器负载更小，而且域名查询的包一般都很小，不会超过512字节，所以可以使用UDP。
>
> DNS在2种情况下，也会使用TCP协议
> 1. 当本地域名服务器收到的查询response的字节数超过512字节的时候，本地域名服务器会进行重发，并使用TCP。
> 2. DNS在进行区域传输的时候使用TCP。因为区域传输一般用于同步主DNS服务器和辅助DNS服务器的内容，所以包一般会比较大，所以使用TCP协议。

# 16.DNS区域传输

> 为了降低DNS服务器的压力，DNS域名空间被分成区域进行管理，每个区域可以由多台DNS服务器进行管理（一台主DNS服务器，多台辅助DNS服务器）。辅助DNS服务器储存着主DNS服务器的数据副本，每3个小时会进行一次同步。

# 17.TCP流量控制

> TCP流量控制是为了解决窗口过大，发送端发送的数据量超过了接受端的接收能力的问题。
>
> TCP流量控制可以在传输过程中动态改变窗口的大小，接收端会向发送端发送自己的缓存区的剩余大小，发送端会根据这个数据动态改变窗口大小。
>
> 当缓存区已满的情况下，发送端会停止发送数据，等到收到接收端的窗口大小更新通知之后再开始发送数据，同时为了防止窗口大小更新数据丢包，发送端会每隔一段时间向接收端发送一个字节大小的窗口大小探测数据段。

# 18.TCP的拥塞控制

> 因为窗口协议允许发送端一次发送大量数据，但是如果网络正处于拥堵状态，突然发送大量数据会使得网络瘫痪，所以TCP引入了慢启动机制。
>
> - 慢启动机制
>
>   - 慢启动机制是指在最开始将滑动窗口大小置为1个MSS大小，当发送端成功接收1个确认应答之后，将窗口大小增加1个MSS。（这个拥塞窗口和流量控制相适应，会选取拥塞窗口和流量控制中较小的一个）。
>
> - 慢启动阈值
>
>   - 当发送端不断收到确认应答，拥塞窗口的大小也会快速增加，所以TCP又引入了慢启动阈值，当拥塞窗口大小超过慢启动阈值，那么每次增加只能按照公式一点点增加
>
>     1个数据段字节数/拥塞窗口字节数 * 一个数据段字节数
>
>   - 慢启动阈值在一开始是没有被设置的，只有在碰到重发超时或高速重传的时候才会被设置。
>
>   - 当遇到超时重发的时候，拥塞窗口会被重置为1个数据段大小，慢启动阈值会被设置为当时拥塞窗口的一半大小。
>
>   - 当遇到高速重传的时候，慢启动阈值会被设置为当前拥塞窗口的一半，拥塞窗口会被重置为慢启动阈值的大小加3个数据段大小。
>
> - 快恢复
>
>   - 快恢复就是当拥塞控制遇到高速重传的时候，拥塞窗口不会被置为1个数据段大小，而是被置为慢启动阈值加3个数据段大小。

# 19.WebSocket协议

> 因为HTTP协议有一个缺陷：HTTP通信只能由客户端发起，为了实现服务端主动向客户端推送信息，最终引入了 WebSocket协议。
>
> - WebSocket的特点
>
>   - 通过WebSocket，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息。
>
>   - WebSocket协议建立在TCP协议之上。
>
>   - WebSocket协议与HTTP协议有良好的兼容，默认端口是80和443，并且WebSocket协议握手时采用HTTP协议。
>
>   - WebSocket没有同源限制，客户端可以和所有服务器进行AJAX通信。
>
>   - 协议标识符是ws，如果加密，就是wss。
>
>     ```{url}
>     ws://example.com:80/some/path
>     ```
>
> - WebSocket解决的问题
>
>   - WebSocket解决了HTTP协议只能由客户端发起通信的缺点。
>
> - WebSocket握手
>
>   - 想要建立WebSocket连接，必须进行一次基于HTTP的握手。
>   - 客户端向服务器端发送请求报文，报文首部字段含有Upgrade字段，表示需要切换通信协议。Upgrade: websocket。
>   - 服务器端在收到这个请求报文之后，会返回一个响应报文。这个响应报文的返回码是101 Swiching Protocols，并且响应报文的首部字段有Upgrade: websocket表示切换协议到websocket。
>
> - WebSocket的客户端API
>
>   1. WebSocket构造函数
>
>      ```{typescript}
>      var ws = new WebSocket('ws://localhost:8080')
>      ```
>
>      调用WebSocket构造函数之后，客户端就会与服务器进行连接。
>
>   2. webSocket.readyState
>
>      ```{typescript}
>      enum readyState{
>        CONNECTING = 0, //表示正在连接
>        OPEN, //表示连接成功，可以进行通信了
>        CLOSING, //表示连接正在关闭
>        CLOSED //表示连接已经关闭或者打开连接失败
>      }
>      ```
>
>      一个使用例子
>
>      ```{typescript}
>      const ws = new WebSocket('...')
>                
>      switch (ws.readyState) {
>        case WebSocket.CONNECTING:
>          // do something
>          break;
>        case WebSocket.OPEN:
>          // do something
>          break;
>        case WebSocket.CLOSING:
>          // do something
>          break;
>        case WebSocket.CLOSED:
>          // do something
>          break;
>        default:
>          // this never happens
>          break;
>      }
>      ```
>
> 
>
>   3. webSocket.onopen（用于指定连接成功后的回调）
>
>      ```{typescript}
>      ws.onopen = function(){
>        ws.send('Hello Server');
>      }
>      ```
>
>      如果要指定多个回调，可以使用addEventListener。
>
>      ```{typescript}
>      ws.addEventListener('open', function(event){
>        ws.send('Hello Server');
>      })
>      ```
>
> 
>
>   4. webSocket.onclose
>
>      用于指定连接关闭之后的回调函数，用法和onopen一样。
>
>   5. webSocket.onmessage
>
>      webSocket的实例对象的onmessage属性，用于指定收到服务器数据后的回调函数。
>
>      ```{javascript}
>      ws.onmessage = function(event){
>        const data = event.data
>      }
>
>      ws.addEventListener('message'.function(event){
>                          const data = evnt.data
>                          })
>      ```
>
>   6. webSocket.send
>
>      webSocket的实例对象的send方法，用于向服务器发送数据。
>
>   7. webSocket.bufferedAmount
>
>      webSocket实例对象的bufferedAmount属性表示还有多少字节的二进制数据没有发送出去，可以用来判断数据是否发送完成。
>
>   8. webSocket.onerrer
>
>      webSocket实例对象的onerror属性，用于指定报错时的回调函数。

# 20.代理服务器

> - 正向代理
>   - 正向代理的应用场景
>     - VPN实际上使用的是正向代理模式，客户端向代理服务器发出请求，并指定源服务器。
>   - 正向代理定义
>     - 正向代理含义是代理服务器代理客户端向源服务器发出请求。
> - 反向代理
>   - 反向代理的应用场景
>     - 分布式实际上使用了反向代理，客户端统一向代理服务器发送请求，再由代理服务器将请求分配给不同的源服务器处理。
>   - 反向代理的定义
>     - 反向代理含义是代理服务器代理源服务器接收请求。

# 21. TCP和UDP的区别

1. TCP面向连接，UDP面向无连接。
2. UDP每个数据包只能传输最多512字节的数据，而TCP报文段的大小由3次握手过程中确定的MSS确定。
3. UDP不需要建立连接，对服务器压力更小，但也因为不需要确认报文，发送端不知道接收端是否收到了。

# 22.TCP保证可靠性的方法

1. seq和ACK，每个TCP报文段的首部seq总是是这个报文段的第一个字节的seq，而ACK总是表示接收端想要收到的下一个TCP报文段的第一个字节的seq。
2. MSS，在进行TCP的3次握手的过程中，接收端与发送端会在报文段首部包含自己能够接受的最大报文长度，最终MSS将选择其中较小的一个。
3. 超时重发 & 高速重传，超时重发是指当发送端发送一个TCP报文段之后， 发送端会开始计时，当超过一定时间没有收到确认报文段，那么就会进行重发。高速重传发生在TCP滑动窗口协议中，如果一个窗口大小是4，但是第二个发送的报文段丢失，接收端就会一直返回同样ACK的报文段，这时就会触发高速重传。
4. 流量控制，TCP流量控制主要是为了动态改变窗口的大小，避免因为接收端缓存区占满而导致丢包的情况。
5. 丢弃重复数据，接收端只会接受它上一次发送的ACK中的seqnumber开头的报文段，其他重复报文段会被丢弃。

# 23. Cookie

- cookie的作用

  - cookie是为了克服http无状态的缺点，cookie可以用于保存状态以及分辨两个http请求是否来自同一个浏览器。

- 不推荐的cookie作用

  - 不推荐使用cookie作为客户端存储，因为cookie最多只能保存4k的数据。
  - 推荐使用localStorage等作为客户端存储方案。

- cookie包含的信息

  - cookie的信息

    1. cookie的名称
    2. cookie的值（cookie保存的数据）
    3. cookie的到期时间
    4. cookie的所属域名（默认是写入cookie的服务器的域名）
    5. cookie生效的路由路径（默认是写入cookie的网页的路由路径）

  - 一个例子

    当用户在访问www.example.com/pin的时候服务器设置了一个cookie，那么这个cookie的默认域名是www.example.com，默认path是/pin，这说明这个cookie只能在浏览器访问www.example.com/pin这个路径及其子路径www.example.com/pin/xxx时浏览器才会在http请求中附上这个cookie。

- 浏览器对cookie数量和大小的限制

  - 不同浏览器对cookie有不同的限制，一般来说，浏览器允许同一个域名设置最多30个cookie，如果超过了限制，浏览器会忽略设置cookie的请求。
  - cookie的最大长度不超过4k

- cookie共享策略

  - cookie是否可以被两个URI的服务器共享是由浏览器同源策略限制的。当两个URI的域名和端口相同（不需要协议相同），那么浏览器在访问这两个URI的时候都会在请求中带上cookie。
  - 当一级域名一致时，不论二级域名&三次域名如何，都可以共享。

- 设置cookie

  - cookie的设置是由服务器在响应报文中的set-cookie首部字段中控制的。

    ```{http}
    Set-Cookie: foo=bar
    Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT;domain=example.com; path=/pin; Secure; HttpOnly
    ```

    我们可以看大这里设置了两个cookie，第一个cookie的名称是foo，第二个cookie的名称是id。第一个cookie的值是bar，第二个cookie的值是a3fWa。

    第二个cookie的过期时间是使用Expires属性设置的，同时domain和path属性设置了浏览器在请求example.com/pin及其子路由时才会在HTTP请求报文中携带上cookie。

- 发送cookie

  - 当满足domain和path的限制后，浏览器在向服务器发出请求的时候会在请求报文中自动带上Cookie首部字段以携带cookie。

    ```{http}
    Cookie: foo=bar
    Cookie: name=value;name1=value1
    ```

    Cookie字段后面可以跟多个Cookie

- 为Cookie设置有效时间

  - Expires、Max-Age
    - 在服务器端返回的响应报文中可以在Set-Cookie设置响应报文。
  - 

- 
