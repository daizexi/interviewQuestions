# 1.读代码题1，闭包和作用域

> ```{javascript}
> function Foo() {
>     var i = 0;
>     return function() {
>         console.log(i++);
>     }
> }
>  
> var f1 = Foo(),
>     f2 = Foo();
> f1(); //0
> f1(); //1
> f2(); //0
> ```
> Foo()函数调用会返回一个匿名函数，这形成了一个闭包（闭包是访问了外部函数作用域中变量的函数）。在正常情况下，函数在执行完毕之后，它的活动对象就会被销毁，其中包含的变量也就被销毁了，但是因为存在闭包，闭包的作用域链中存在对函数活动对象的引用，所以外部函数中的变量还存在。
> 注意这里，函数是引用值，所以每次调用Foo()都会生成不同的函数引用值，不同的函数引用值会保存不同的Foo活动对象中的变量i，所以调用f1()导致f1()保存的变量i增加是不会影响f2()保存的变量i的。

# 2.代码阅读题2，局部变量和参数按值传递

> ```{javascript}
> var bb = 1;
> function aa(bb) {
>     bb = 2;
>     alert(bb); //2
> };
> aa(bb);
> alert(bb); //1
> ```
>
> 函数aa中，变量bb原本没有使用关键字进行声明，会在JavaScript引擎对其进行LHS查询（赋值）的时候，将其视为全局作用域的变量对象（window对象）下的变量，但是因为函数aa()传入了1个参数bb，所以函数的活动对象中存在bb的声明，所以JavaScript引擎在对bb进行LHS查询的时候只会修改函数活动对象中的bb变量，所以全局作用域的变量对象中的bb变量不会被修改。
