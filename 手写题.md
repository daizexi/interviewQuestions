# 1.用setTimeout实现setInterval



# 2.手写防抖节流

```{javascript}
function debounce(fn,delay)
{
    let timer;
    return function(){
        if(timer !== undefined)
            {
                clearTimeout(timer);
            }
        timer = setTimeout(fn,delay);
    }
}
```
```{javascript}
function throttle(fn,delay)
{
    let isOk = true;
    return function()
    {
        if(!isOk)
            {
                return;
            }
        fn();
        isOk = false;
        setTimeout(() => isOk = true,delay);
    }
}
```

# 3.手写instanceof



# 4.手写typeof



# 5.手写reduce

> reduce是Array原型上的方法，用于遍历数组
>
> ```{javascript}
> Array.prototype.reduce = function(fn,init)
> {
>     let arr = this;
>     let total = init || arr[0];
>     
>     for(let i = init ? 0:1;i < arr.length;i++)
>         {
>             total = fn(total,arr[i],i,arr);
>         }
>     return total;
> }
> ```

# 6.手写JSONP

> ```{javascript}
> function setJsonp(src)
> {
>     let script = document.createElement('script');
>     script.setAttribute("type","text/javascript");
>     script.src = src;
>     document.body.appendChild(script);
> }
> window.onload = function()
> {
>     setJsonp('https://example.com/ip?callback=foo');
> }
> function foo(data)
> {
>     ...
> }
> ```

# 7.手写深拷贝

> ```{javascript}
> function deepCopy(obj)
> {
>     let objNew = new Object();
>     for(let item in obj)
>         {
>             objNew[item] = obj[item];
>         }
>     return objNew;
> }
> ```

# 8.手写快速排序（不稳定排序）

> ```{javascript}
> function quickSort(arr)
> {
>     if(arr.length === 0)
>         {
>             return [];
>         }
>     let pivot = arr[0];
>     let left = [];
>     let right = [];
>     for(let i = 1;i < arr.length;i++)
>         {
>             if(arr[i] > pivot)
>                 {
>                     right.push(arr[i]);
>                 }
>             else{
>                 left.push(arr[i]);
>             }
>         }
>     return quickSort(left).concat(pivot,quickSort(right));
> }
> ```

# 9.手写冒泡排序（稳定排序）

> ```{javascript}
> function bubbleSort(arr)
> {
>     for(let i = 0;i < arr.length;i++)
>         {
>             for(let j = 0;j < arr.length - 1 - i;j++)
>                 {
>                     if(arr[j] > arr[j + 1])
>                         {
>                             let temp = arr[j];
>                             arr[j] = arr[j + 1];
>                             arr[j + 1] = temp;
>                         }
>                 }
>         }
> }
> ```

# 10.手写选择排序（不稳定排序）

> - 选择排序的关键在于，从未排序部分找出最小的放在排序部分的最后。
>
> ```{javascript}
> function selectionSort(arr)
> {
>  for(let i = 0;i < arr.length;i++)
>      {
>          let minIndex = i;
>          for(let j = i + 1;j < arr.length;j++)
>              {
>                  if(arr[j] < arr[minIndex])
>                      {
>                          minIndex = j;
>                      }
>              }
>          let temp = arr[i];
>          arr[i] = arr[minIndex];
>          arr[minIndex] = temp;
>      }
> }
> ```

# 11.手写插入排序（稳定排序）

> 插入排序的关键在于，把当前遍历到的元素向前面已经排好序的序列中插入。
> ```{javascript}
> function insertSort(arr)
> {
>     for(let i = 1;i < arr.length;i++)
>         {
>             let temp = arr[i];
>             let key = i - 1;
>             while(key >= 0 && arr[key] >= temp)
>                 {
>                     arr[key + 1] = arr[key];
>                     key--;
>                 }
>             arr[key + 1] = temp;
>         }
> }
> ```
>

# 12.手写归并排序（稳定排序）

> ```{javascript}
> function mergeSort(arr)
> {
>     if(arr.length > 1)
>         {
>             let mid = Math.floor(arr.length/2);
>             let left = mergeSort(arr.slice(0,mid));
>             let right = mergeSort(arr.slice(mid));
>             arr = merge(left,right);
>         }
>     return arr;
> }
> function merge(left,right)
> {
>     let res = [];
>     let index1 = 0;
>     let index2 = 0;
>     while(index1 < left.length && index2 < right.length)
>         {
>             if(left[index1] < right[index2])
>                 {
>                     res.push(left[index1++]);
>                 }
>             else{
>                 res.push(right[index2++]);
>             }
>         }
>     return res.concat(index1 < left.length ? left.slice(index1):right.slice(index2));
> }
> ```

# 13.实现数组去重的方法

> 1. 使用set
>
>     ```{javascript}
>     let set = new Set(arr);
>     arr = Array.from(set);
>     ```
>
> 2. 使用哈希表
>
>    ```{javascript}
>    let map = new Map();
>    for(let i = 0;i < arr.length;i++)
>        {
>            if(!map.has(arr[i]))
>                {
>                    map.set(arr[i],i);
>                }
>            else{
>                arr.splice(i,1);
>                i--;
>            }
>        }
>    ```
>
>    
>
> 3. 使用双指针
>
>    ```{javascript}
>    arr.sort((a,b) => a-b);
>    let left = 0;
>    let right = 0;
>    while(right < arr.length)
>        {
>            if(arr[left] === arr[right])
>                {
>                    right++;
>                }
>            else{
>                let len = right - left - 1;
>                arr.splice(left+1,len);
>                right = right - len;
>                left = right;
>            }
>        }
>    let len = right - left - 1;
>    arr.splice(left+1,len);
>    ```
>

# 14.使用闭包的方法，每秒钟打印数组中的一个数字

> ```{javascript}
> for(let i = 0;i < arr.length;i++)
> {
>     (function fn()
>     {
>         return setTimeout(() => console.log(arr[i]),1000 * i);
>     })(i);
> }
> ```

# 15.手写Array.prototype.indexOf()

> ```{javascript}
> Array.prototype.indexOf = function(target,init)
> {
>   let arr = this;
>   let start = init || 0;
>   for(let i = start;i < arr.length;i++)
>   {
>     if(arr[i] === target)
>     {
>       return i;
>     }
>   }
>   return -1;
> }
> ```

# 16.手写展平数组

> ```{javascript}
> Array.prototype.flat = function(depth)
> {
>   let res = [];
>   let arr = this;
>   
>   function helper(arr,res,d)
>   {
>     if(d === depth && depth !== undefined)
>     {
>       res.push(arr);
>       return;
>     }
>     for(let i = 0;i < arr.length;i++)
>     {
>       if(Array.isArray(arr[i]))
>       {
>         helper(arr[i],res,d + 1);
>       }
>       else{
>         res.push(arr[i]);
>       }
>     }
>   }
>   
>   helper(arr,res,0);
>   return res;
> }
> ```
