# 1.贪心算法最优性证明（调度算法）

首先我们引入一个问题Interval Scheduling（调度问题）

> 现在你拥有一个资源，它可能是一间教室、一台计算机等，许多人都要求使用这个资源（计算机），但是这个资源（计算机）同一时间只能被一个人使用，我们想要达成的目标是，从起始时间s开始到结束时间f，我们可以尽可能多的满足使用这个资源的要求。

我们也可以更正式的理解这个问题。

> 现在我们有一组请求 request = {1, 2, 3, ... , n}，request<sub>i</sub>的开始时间是start<sub>i</sub>，结束时间是end<sub>i</sub>，我们的目标是从集合request中选出尽可能多的不重合的request。

贪心算法通常都是很自然的思路，我们可以想到

1. 总是选择最先开始的request，这样可以使我们的资源更早的投入使用。
2. 总是选择持续时间最短的request，这样可以使我们的资源更快的被释放，这样可以使更多的请求被接受。
3. 总是选择冲突最少的request，这样可以使得我们拒绝更少的request。
4. 总是选择最先结束的request。

对于每一个贪心策略，我们都需要证明它是否能够一步一步的到达最优解。

1. 我们可以首先声明一个最优解O。
2. 如果在第一步，可以证明贪心策略不比最优解差。
3. 我们假设第k步，贪心策略的选择也不必最优解差。
4. 那么我们只要证明第k+1步，贪心策略的选择也可以接受，那么就说明贪心策略可以达到最优解。

对于第4个思路，我们可以给出最优性证明。

> 我们期望证明它得到的可以接受的request数是A，最优解得到的可以接受的request数是O，如果我们可以证明A === O，那么就说明这个贪心策略将会得到最优解。
>
> 接下来，我们假设A中的第i个request的结束时间是end<sub>i</sub>，O中第i个request的结束时间是End<sub>i</sub>，如果我们可以证明end<sub>i</sub>不迟于End<sub>i</sub>，那么贪心策略会是最优的。
>
> 1. 当i === 1，因为贪心策略选择的是所有request中最早结束的request，所以end<sub>1</sub>必然不迟于End<sub>1</sub>。
>
> 2. 我们假设当i === k时，end<sub>k</sub>也不迟于End<sub>k</sub>。
>
> 3. 我们现在要证明当i === k + 1时，end<sub>k+1</sub>不迟于End<sub>k+1</sub>。
>
>    因为贪心策略始终选择剩下的（没有被拒绝，也没有被接受的）request中的最早完成的，又因为前一步中end<sub>k</sub>不迟于End<sub>k</sub>，所以对于第k+1步，贪心策略也必然选择不迟于最优解的request，这样我们就证明贪心策略的最优性。

**我们通常是使用数学归纳法来证明最优解的。**



# 2.二分查找模板

- 二分查找的前提

  - 二分查找必须保证有序性。（实际上有序性是常见的判断答案不在某一半中的条件，如果我们有其他方法判断某一半中必然不包含答案，那么也可以不有序）。

- 二分查找的本质

  - 实际上二分查找是通过逻辑关系判断目标答案必然不在某一半数据中，因此不再在这些必然不包含答案的数据中找答案。
  - 因此我们只需要保证可以推断出某一半必然不包含数组，那么就可以使用二分查找。

- 二分查找的时间复杂度

  - 进行一次二分查找的时间复杂度是O(logn)，n是数据的规模。

- 二分查找的模板

  1. 在nums中查找某个存在值target（nums升序）

     - right === nums.length - 1, while(left <= right), right = mid - 1

       ```{js}
       function binarySearch(nums,target)
       {
         let left = 0;
         let right = nums.length - 1;
         while(left <= right)
           {
             let mid = Math.floor((left + right) / 2);
             if(nums[mid] === target)
               {
                 return mid;
               }
             else if(nums[mid] > target) 
               {
                 right = mid - 1;
               }
             else{
               left = mid + 1;
             }
           }
       }
       ```

       这里的舍弃条件和nums升序有关，因为nums升序，所以当nums[mid] > target，那么说明mid之后的数据都必然不包含答案，所以舍弃。

     - right === nums.length, while(left < right), right = mid;

       ```{js}
       function biarySearch(nums,target)
       {
         let left = 0;
         let right = nums.length;
         while(left < right)
           {
             let mid = Math.floor((left + right)/2);
             if(nums[mid] === target)
               {
                 return mid;
               }
             else if(nums[mid] > target)
               {
                 right = mid;
               }
             else{
               left = mid + 1;
             }
           }
       }
       ```

       

  2. 在nums中查找某个不存在的值，如找到大于target的第一个元素（也就是假设将target插入nums，target右边的第一个元素的下标）。

     - right === nums.length - 1, while(left <= right), right = mid - 1

       ```{js}
       function binarySearch(nums,target)
       {
         let left = 0;
         let right = nums.length - 1;
         while(left <= right)
           {
             let mid = Math.floor((left + right)/2);
             if(nums[mid] > target)
               {
                 right = mid - 1;
               }
             else{
               left = mid + 1;
             }
           }
         return left;
       }
       ```

       最终left就指向target右边第一个元素的下标。

     - right === nums.length, while(left < right), right = mid;

       ```{js}
       function binarySearch(nums,target)
       {
         let left = 0;
         let right = nums.length;
         while(left < right)
           {
             let mid = Math.floor((left + right)/2);
             if(nums[mid] > target)
               {
                 right = mid;
               }
             else{
               left = mid + 1;
             }
           }
         return left;
       }
       ```

  3. 在nums中查找某个可能存在的target的右边第一个元素的下标。

     - right === nums.length - 1, while(left <= right), right = mid - 1;

       ```{js}
       function binarySearch(nums,target)
       {
         let left = 0;
         let right = nums.length - 1;
         while(left <= right)
           {
             let mid = Math.floor(left + (right - left)/2);
             if(nums[mid] >= target)
               {
                 right = mid - 1;
               }
             else{
               left = mid + 1;
             }
           }
         return left;
       }
       ```

       我们可以看到，找target的右边第一个元素，返回的都是left。

     - right === nums.length, while(left < right), right = mid;

       ```{js}
       function binarySearch(nums,target)
       {
         let left = 0;
         let right = nums.length;
         while(left < right)
           {
             let mid = Math.floor(left + (right - left)/2);
             if(nums[mid] >= target)
               {
                 right = mid;
               }
             else{
               left = mid + 1;
             }
           }
         return left;
       }
       ```

  4. 在nums中查找某个可能存在的target的左边第一个元素的下标。

     - 两个模板都可以

       ```{js}
       function binarySearch(nums,target)
       {
         let left = 0;
         let right = nums.length - 1;
         while(left <= right)
           {
             let mid = Math.floor(left + (right - left)/2);
             if(nums[mid] >= target)
               {
                 right = mid - 1;
               }
             else{
               left = mid + 1;
             }
           }
         return right;
       }
       ```

       对于找target右边第一个元素，返回left。

       对于找target左边第一个元素，返回right。

- 二分查找技巧
  - 一个常用的技巧是当我们判断A部分必然不包含答案的条件过于复杂，而判断B答案是否包含答案的条件比较简单，那么可以使用if else语句。配合LeetCode 33理解。