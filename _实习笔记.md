# 1. sticky定位

> - 介绍
>
>   - sticky定位可以看成是相对定位和固定定位的混合，设置了sticky定位的元素在跨越指定阈值前表现为相对定位，当跨越指定阈值之后为固定定位。
>   - sticky定位不脱离文档流。（即使是在固定定位阶段也不会脱离文档流）。
>   - sticky定位的top属性、bottom属性等会相对于距离设置了sticky定位的元素最近的具有滚动机制的元素计算。
>     - 滚动机制
>       - 当一个元素的overflow属性不是visible的时候，那么这个元素是具有滚动机制的。
>       - viewport具有滚动机制。
>
> - 代码
>
>   ```{css}
>   #target {
>     position: sticky;
>     top: 10px;
>   }
>   ```
>
>   - 这段代码表示在滚动页面的过程中，当元素top距离viewport小于10px之前，元素定位为相对定位，相对于最近父元素中的块元素定位。
>   - 当元素top距离viewport小于10px开始，元素定位为固定定位。（相当于元素将固定在top距离viewport 10px处）。
>
> - 失效情况
>
>   - 有4种情况可能导致sticky定位失效。
>     - 我们设置了 ` position: sticky`，如果没有设置`top、bottom、left、right `，那么sticky定位也是不会生效的。
>     - 父元素没有设置了sticky定位的子元素高，这样sticky定位不会生效。
>     - 父元素滚出了viewport，这样设置了sticky定位的子元素也无法继续固定定位。
>     - 设置为sticky定位的元素的任何父元素设置了overflow: visible之外的值。（如设置了overflow: hidden会导致失效）。
>
> - sticky定位生效原理
>
>   - W3C官方文档的定义，Sticky positioning is similar to relative positioning except the offsets are automatically calculated in reference to the nearest scrollport.
>   - sticky定位和相对定位很像，除了一点，sticky定位会根据离它最近滚动容器计算偏移量。
>
> - 从生效原理看sticky定位失效原因
>
>   - 第一种失效情况（没有设置top等）
>     - 根据生效原理，当设置了sticky定位的元素没有指定偏移量的时候，那么它的表现和relative定位一致。
>   - 第二种失效情况（没有为父元素设置高度，使得父元素和子元素一样高）
>     - 在这种情况下，实际上sticky定位只是无法表现出来，所以表现为不生效。
>     - 即使设置了sticky定位的元素，因为没有脱离文档流，所以它必须保持在它的父元素内部，所以当父元素滚出viewport之后，stikcy定位的元素也离开了viewport，这使得sticky定位无法表现出来。
>   - 第三种失效情况（和第二种失效情况属于一种情况）
>   - 第四种失效情况（sticky定位的元素的任何父元素设置了overflow属性）
>     - 因为设置了overflow属性之后，就将成为具有滚动机制的元素，这时设置了sticky定位的元素计算偏移量的对象不再是viewport，而是这个设置了overflow属性的父元素。
>     - 并且因为sticky定位的元素没有脱离文档流，所以这种情况下，sticky定位的元素也会随着父元素一起滚出viewport。

# 2. text-indent

> - 作用
>   - text-indent可以控制一个块元素的首行文本的缩进
> - 技巧
>   - 当`font-size: 14px`，我们可以设置`text-indent: 28px`，这样首行文本会缩进两个字符。
> - 失效原因
>   - 如果对非块元素设置text-indet，这样是不会生效的。（对\<span>元素设置text-indent不生效，需要把\<span>先转成块元素）。

# 3. vue2 watch属性

> - 作用
>
>   - watch属性可以侦听某个响应式数据，并指定一个函数，当侦听数据改变时，就调用这个函数。
>   - watch属性的处理函数有两个参数（都是可选），第一个参数是数据变化后的值（newVal），第二个参数是数据变化前的值（oldVal），可以直接在处理函数中使用这两个参数。
>
> - 侦听对象
>
>   - watch属性可以侦听
>     - data中的数据
>       - 如果这个数据是一个对象，那么也可以侦听这个对象中具体某个属性（需要确保这个属性不为undefined）。
>     - 计算属性中的数据（某个计算属性）
>
> - 用法
>
>   - 基础用法
>
>     ```{JavaScript}
>     new Vue({
>     	el: '#app',
>     	data: {
>     		firstName: 'aaa',
>     		lastName: 'bbb',
>     	},
>     	watch: {
>     		firstName: function(newVal, oldval){
>     			...
>     		}, //两种写法都可以
>     		lastName(newVal,oldVal){
>     			...
>     		},
>     	},
>     })
>     ```
>    
>     这里的2种写法实际上是使用了ES6的简写对象方法名特性。
>    
>   
>  - 高级用法（包含handler方法和immediate属性）
> 
>    - 当需要绑定watch属性之后立即执行，可以使用immediate属性。
> 
>       ```{javascript}
>       new Vue({
>         el: '#app',
>         data: {
>           firstName: 'aaa',
>           lastName: 'bbb',
>         },
>         watch: {
>           firstName: {
>             handler(newVal, oldVal){
>               ...
>             },
>             immediate: true,
>           },
>         },
>       })
>      ```
> 
>       - handler方法，其实就是绑定的处理函数，在基础用法中，Vue编译之后，也会将指定的处理函数编译成handler方法。
>      - `immediate: true`，表示Vue编译到这个watch属性后，就会立即执行一次handler方法。（基础写法是不会这样立即执行的，只有等待侦听数据改变之后，才会执行handler方法）。
> 
>    - 为data中某个对象的某个属性添加监听器（如果直接监听对象的话，是检测不到对象中属性的变化的）
> 
>       ```{javascript}
>       new Vue({
>         el: '#app',
>         data: {
>           obj: {
>             name: 'a',
>           },
>         },
>         watch: {
>           'obj.a': {
>             handler(newVal, oldVal){
>               ...
>             },
>           },
>         },
>       })
>      ```
> 
>      这样Vue会一层一层解析，直到遇到属性a，才会为属性a添加监听函数。
> 
>      这种情况要保证，obj中必然存在属性a，也就是属性a的值不为undefined。
> 
>      也可以使用deep属性
> 
>       ```{typescript}
>       new Vue({
>         el: '#app',
>         data: {
>           obj: {
>             name: 'a',
>           },
>         },
>         watch: {
>           obj: {
>             handler: function(){
>               ...
>             },
>             deep: true,
>           }
>         }
>       })
>       ```
>       

# 4. Charles使用

> - 使用charles配置在iphone上访问ppe或boe
>
>   ![截屏2022-01-26 下午7.57.07](/Users/bytedance/Desktop/截屏2022-01-26 下午7.57.07.png)
>
> ​      点击install Charles Root Certificate on a Mobile Device or Remote Browser
>
> - 点击之后会出现一个窗口
>
>   ![截屏2022-01-26 下午8.27.20](/Users/bytedance/Desktop/截屏2022-01-26 下午8.27.20.png)
>
>   - 接下来首先在iphone上配置http proxy（这部分可以在网上找到流程）
>     - 打开设置，进入无线局域网
>     - 点击已连接wifi最右端的 i 按钮
>     - 点击HTTP代理的配置代理
>     - 配置服务器和上面弹窗中的ip地址一致（10.76.53.83），配置端口和上面窗口的一致（8888）
>
>   - 然后打开iphone的浏览器访问 chls.pro/ssl，这时会下载一个配置文件
>     - 下载配置文件之后，首先需要安装，然后需要信任这个配置文件
>       - 安装过程（iphone安装信任文件的过程可以在网上找到）
>         - 打开设置，进入通用
>         - 进入VPN与设备管理
>         - 点击安装配置文件
>       - 信任配置文件（iphone信任安装的配置文件的流程可以在网上找到）
>         - 打开设置，搜索信任
>         - 进入搜索结果，可信的证书
>         - 点击证书信任设置
>         - 选择刚刚安装的配置文件，并信任
>
> - 在charles上配置header
>
>   ![截屏2022-01-26 下午8.39.54](/Users/bytedance/Desktop/截屏2022-01-26 下午8.39.54.png)
>
>   - 点击rewrite，出现一个窗口
>
>     ![截屏2022-01-26 下午8.41.10](/Users/bytedance/Desktop/截屏2022-01-26 下午8.41.10.png)
>
>   - 点击Add按钮，会出现一个untitled set，点击这个untitled set。
>
>     ![截屏2022-01-26 下午8.42.36](/Users/bytedance/Desktop/截屏2022-01-26 下午8.42.36.png)
>
>   - 点击上面图片中右边这个Add按钮，会出现下面这个窗口
>
>     ![截屏2022-01-26 下午8.43.36](/Users/bytedance/Desktop/截屏2022-01-26 下午8.43.36.png)
>
>   - 先配置后端访问ppe的protocol和host以及path
>
>     ![截屏2022-01-26 下午8.45.08](/Users/bytedance/Desktop/截屏2022-01-26 下午8.45.08.png)
>
>   - 下面配置前端访问ppe
>
>     ![截屏2022-01-26 下午8.45.42](/Users/bytedance/Desktop/截屏2022-01-26 下午8.45.42.png)
>
>   - 下面配置add request header
>
>     ![截屏2022-01-26 下午8.46.30](/Users/bytedance/Desktop/截屏2022-01-26 下午8.46.30.png)
>
>   - 点击上面图片中的Add按钮，进入配置窗口，下面添加了一个request header
>
>     ![截屏2022-01-26 下午8.47.43](/Users/bytedance/Desktop/截屏2022-01-26 下午8.47.43.png)
>
>     *<strong>注意要配置Type</strong>*
>
> - 在charles上检查是否配置成功
>
>   ![截屏2022-01-26 下午8.37.08](/Users/bytedance/Desktop/截屏2022-01-26 下午8.37.08.png)
>
>   点击这个扫帚图标，会清理之前的抓包，然后看新抓包是否存在

# 5. v-cloak指令

> - 作用
>
>   - v-cloak指令用于设定使用了这个指令的HTML元素或组件的样式。
>   - 使用v-cloak指令绑定的样式会在Vue实例（组件）编译完成后被移除。
>   - v-cloak指令主要用于在网络较慢的情况下，当网页还在加载Vue，导致Vue来不及渲染，导致网页显示出Vue的源代码的问题。
>
> - 代码
>
>   ```{html}
>   <template>
>     <div id="app" v-cloak>
>       {{ context }}
>     </div>
>   </template>
>   
>   <script lang='ts'>
>     export default {
>       components: {},
>       data: () => {
>         return{
>           context: 'context内容',
>         }
>       },
>       props: {},
>       computed: {},
>       watch: {},
>       methods: {},
>       mounted(){},
>     }
>   </script>
>   <style lang='scss'>
>     [v-cloak]{
>       display: none;
>     }
>   </style>
>   ```
>
> - 实际工程
>
>   - 在实际工程中，内容都是由路由挂载来实现的，所以基本上不会遇到需要使用v-cloak的这种情况。

# 6.后端返回的数据中包含enum类型数据时

> 假设某一个字段是 status，它是enum类型的数据，那么返回值会是具体的enum类型中的某个值。
>
> enum类型感觉上类似于boolean，当返回boolean值的时候，会返回确定的某个值（true或false），同样，当返回enum时，会返回某个确定的值。

# 7.TS中的枚举对象（enum）

> - 枚举简介
>
>   - 枚举是一个键值对的形式，可以看成是JavaScript中的JSON对象一样。
>
>   - TS使用 enum 关键词声明枚举。
>
>   - 如何创建一个枚举，以数字枚举举例
>
>     - 使用enum关键词，关键词后接枚举的名称，然后创建一个大括号块，并在这个块里指定枚举成员。
>
>     ```{typescript}
>     enum Direction{
>       North = 1,
>       East, //默认递增，所以值是2
>       South, //值是3
>       West, //值是4
>     };
>     ```
>
>     
>
> - 数字枚举
>
>   - 数字枚举的成员都是number类型的。
>
>   - 对于数字枚举，如果没有对枚举对象中的枚举成员赋值，那么会默认从枚举对象中的第一个枚举成员的值是0，并依次递增。
>
>   - 如果想利用枚举对象的不同枚举成员获取不同的状态，那么可以使用switch。（因为后端返回enum类型的时候，尤其是数字枚举，只会返回对应的数字值）
>
>     - ```{typescript}
>       enum liveStatus{
>         Living = 1,
>         reply,
>         preview,
>       }
>                                                                                                                       
>       swicth (status)
>       case liveStatus.Living:
>        return '直播中'
>       case liveSatus.reply:
>        return '回放'
>       case liveStatus.preview:
>        return '预告'
>
>   - 数字枚举的反向映射
>
>     - 数字枚举允许从value访问到key的反向映射。
>
>       ```{typescript}
>       enum device{
>         phone = 1,
>         notebook,
>         desktop,
>       }
>       ```
>
>       我们可以知道，phone对应的value是1，notebook对应的value是2，desktop对应的value是3。
>
>       正常来说，我们可以利用notebook来访问到2
>
>       ```{typescript}
>       console.log(device.notebook) //2
>       ```
>
>       对于数字枚举，我们也可以通过2来访问到notebook。
>
>       ```{typescript}
>       console.log(device[2]) //notebook
>       ```
>
>       
>
> - 字符串枚举
>
>   - 字符串枚举的枚举成员都是string类型。
>
>   - 字符串枚举没有反向映射。
>
>     ```{typescript}
>     enum device{
>       phone = "1",
>       notebook = "2",
>       desktop = "3",
>     }
>     ```
>
>   - 字符串枚举不能递增，所以必须对字符串枚举对象中的每一个枚举成员赋值。
>
>     ```{typescript}
>     enum device{
>       phone = "1",
>       notebook
>     }
>     ```
>
>     这样就会报错，错误是“枚举成员必须具有初始化表达式”。
>
>   - 
>
> - 异构枚举
>
>   - 一个异构枚举对象可以包括2种枚举成员
>
>     - 数字枚举成员
>     - 字符串枚举成员
>
>   - 我们很少使用异构枚举
>
>     ```{typescript}
>     enum Person{
>       name = "aaa",
>       age = 18
>     }
>     ```
>
>   - 异构枚举中的常见错误
>
>     ```{typescript}
>     enum Person{
>       name = "aaa",
>       age = 3*6
>     }
>     ```
>
>     上面的枚举会报错，错误是“含有字符串值成员的枚举中不允许使用计算值”，含义是当枚举对象中存在有value是字符串的枚举成员的时候，不能将其他枚举成员的value设置为计算值。
>
> - 枚举成员的值的2种形式：计算值和常量
>
>   - 枚举对象中的每一个枚举成员都对应一个value，这个value有2种形式，它可能是计算值 或 常量。
>
>   - 我们可以通过枚举成员表达式来判断枚举成员的value是计算值还是常量。只要是枚举成员的value是枚举成员表达式，那么这个value一定是常量。
>
>   - 判断是否是枚举成员表达式的方法
>
>     - 当满足以下5个条件中的任一个，那么就是枚举成员表达式
>       - 一个枚举表达式字面量（主要是字符串字面量或数字字面量）。
>       - 一个对之前定义的常量枚举成员的引用
>       - 带括号的常量枚举表达式
>       - 一元运算符 ++、 -- 其中任一个应用在了常量枚举表达式
>       - 常量枚举表达式是二元运算符 + 、-、*、/、%、<<、>>、&、｜、^的操作对象。如果求值后值为NaN或Infinity，那么会在编译阶段报错。
>
>   - 常量例子
>
>     ```{typescript}
>     enum Obj{
>       index, //枚举表达式字面量
>       index1 = index, //引用常量枚举成员
>       age = 2 << 1, //枚举表达式字面量参与二元运算符
>       num = 30 | 2,
>       num1 = 10 + 29
>     }
>     ```
>
>     
>
>   - 计算值例子
>
>     ```{typescript}
>     enum Obj{
>       nameLen = 'aaa'.length, //不满足上面任何条件，那么是计算值
>       num = Math.random() * 100
>     }
>     ```

# 8.浏览器自带实现鼠标悬浮省略文本后显示完整文本

> 可以在标签上添加title属性，在使用框架时，可以将数据动态绑定到title属性上。

# 9.img标签自适应设置方法（不拉伸插入的图片）

> - 可以给img标签设置一个CSS属性来控制，object-fit。（object-fit控制图片展示方式）
>   - object-fit属性有5个属性
>     - fill，默认值。使图片拉伸填满整个容器，不保证保持原有比例，可能导致图片看上去和设计图不一致。
>     - contain，保持原有尺寸比例缩放，保证整个图片都出现在容器中，但是可能使得图片无法将容器填满，导致容器中出现空白。
>     - cover，保持原有尺寸比例缩放，并保证宽度和高度至少有一个和容器一致（尺寸小的一致），因此将object-fit设置为cover可能会让图片部分区域超出容器范围而不可见。
>     - none，保持原有尺寸比例，将object-fit设置为none，会使得图片保持原来尺寸大小，多出的部分隐藏。
>     - scale-down，当实际图片尺寸大于容器尺寸时，表现为contain，当实际图片尺寸小于容器尺寸，表现为none。ß

# 10.将字体设置小于最小字号的方法

> - 浏览器中存在最小字号，也就是最小font-size。
>
>   - 最小字号在chrome中是12px。
>   - 当我们试图在Chrome中设置font-size: 8px的时候，会发现设置失败，最终字号会是12px。（可以在开发者工具中查看）。
>
> - 假设我们想要设置font-size: 8px;，我们应该如何设置
>
>   - 可以了利用scale来缩小字体
>
>     ```{scss}
>     .target{
>       font-size: 16px;
>       transform: scale(0.5,0.5);
>     }
>     ```

# 11.当合并分支的时候出现需要locally rebase的处理方法

> - 问题描述
>
>   - 当使用git lab想要合并分支A到分支B时，出现了如下图的提示
>
>     ![截屏2022-02-16 下午2.59.43](/Users/bytedance/Desktop/截屏2022-02-16 下午2.59.43.png)
>
> - 问题解决方法
>
>   - 上面的图片提示我们需要在本地rebase之后才可以合并，所以我们的问题实际上是如何在本地rebase代码。
>
>   - 可以按照以下步骤完成rebase locally，假设待合并分支是A，目标分支是B
>
>     - 首先checkout到目标分支B，先进行一次pull操作，目的是将远程仓库的分支B上的commits全部拉取到本地仓库的分支B。
>
>     - 第二步，checkout回待合并分支A
>
>     - 第三步，在FORK中右键点击目标分支B（在FORK的左部灰色区域中右键分支B）
>
>     - 第四步，选择下图中的Rebas on 'release/live'。
>
>       ![截屏2022-02-16 下午3.34.22](/Users/bytedance/Desktop/截屏2022-02-16 下午3.34.22.png)
>
>     - 第五步，点击弹出窗口中的rebase按钮
>
>     - 第六步，解决冲突。

# 12. git rebase的作用

> 

# 13.使用apply、call、bind修改函数的this指向的作用分析

> - 普通函数内部的this会随着调用它的对象的变化而变化，在一般情况下，函数的this对象的指向改变不会产生影响，但是当函数内部使用了this，这时我们就需要注意是否需要使用apply、call、bind来改变函数的this对象的指向。
>   - 只有在函数内部代码使用了this，这时才需要考虑使用apply、call、bind来修改普通函数的this指向。

# 14. CSS中常用属性设置百分号是如何计算的

> - 百分号的作用
>
>   - 我们使用百分号作为一些CSS属性的值可以实现自适应的效果。
>   - 但是为了正确的使用百分号，我们需要明确不同CSS属性的百分号是相对于哪个值计算的。
>
> - 不能使用百分号作为属性值的属性
>
>   - border-width属性不能使用百分号作为属性值。
>
> - 可以使用百分号的属性
>
>   - line-height
>
>     - line-height的百分号值是相对于当前元素的font-size值计算的，如当前元素font-size: 12px;，那么line-height: 100%;表示line-height的值是12px。
>     - line-height属性常用来使文本垂直居中。
>
>   - vertical-align
>
>     - vertical-align的百分号是相对于当前元素的line-height值计算的。
>
>     - 当vertical-align的值是数值时，表示相对于基线上下位移，正值向上，负值向下。
>
>     - vertical-align常用于使设置了这个属性的元素相对于父元素的对齐方式。
>
>     - vertical-align属性只能设置于inline、inline-block元素才能起作用。
>
>     - vertical-align的默认值是baseline。
>
>       ```{html}
>       <div class="wrapper">
>         <span>aaa</span>
>       </div>
>       <style>
>         .wrapper{
>           width: 200px;
>           height: 200px;
>         }
>         span{
>           vertical-align: middle;
>         }
>       </style>
>       ```
>
>   - font-size
>
>     - font-size的百分号是相对于父元素的font-size计算的。
>
>   - text-indent
>
>     - text-indent是相对于当前元素的包含块计算的。
>   
>   - margin（top、left、right、bottom）
>   
>     - 以父元素的width计算。
>   
>   - padding（top、left、right、bottom）
>   
>     - 以父元素的width计算。

# 15.JavaScript中的try ... catch ... finally结构

> - 作用
>
>   - 当我们在进行接口请求时，应该将请求接口与相关处理代码放在try代码块中，这样可以捕获请求接口中出现的错误。
>
> - 代码结构
>
>   - try代码块中的代码会尝试执行，如果try中的代码执行过程中出现了问题，那么catch代码块中的代码就会执行。
>
>   - finally代码块中的代码最终必然会执行（不论try代码块中的代码是否执行出错）。
>
>   - finally代码块在try和catch代码块后面执行。
>   
>   - 当try代码块中的异步操作加了await关键字，那么finally代码块一定在try代码块执行完成之后执行。
>   
>     ```{javascript}
>     try {
>       nonExistentFunction();
>     } catch (error) {
>       console.error(error);
>       // expected output: ReferenceError: 
>     } finally{
>       console.log('excuted');
>     }
>     ```

# 16.Vue3中的Composition API Ref和Reactive

> - Composition API
>
>   - Vue3最大的特点在于引入了Composition API，而Composition API中的Ref和Reactive允许我们创建响应式数据。
>
> - Vue2中的响应式
>
>   - 如果想要在Vue2中创建响应式数据，那么需要在data函数中返回的对象中声明这个数据。
>
>     ```{html}
>     <template>
>       <h1>{{ title }}</h1>
>     </template>
>     <script>
>       export default {
>         data: () => {
>           return{
>             title: 'title'
>           };
>         },
>       };
>     </script>
>     ```
>
>     如果不在data函数中返回的对象中声明这个数据，那么这个数据将不是响应式的。（需要经过Vue.$set()将不在data中声明的数据转化为响应式数据）。
>
> - Vue3中的响应式
>
>   - 在Vue3中我们可以使用ref或reactive来创建响应式数据。
>
>     ```{html}
>     <template>
>       <h1>{{ title }}</h1>
>     </template>
>     <script>
>       import {ref} from 'vue';
>       export default {
>         setup(){
>           const title = ref('Hello, Vue3.');
>                                                         
>           setTimeout(() => {
>             title.value = 'New Title';
>           },5000);
>           return {
>             title
>           };
>         },
>       }
>     </script>
>     ```
>
> - Ref
>
>   - 如果需要创建原始数据类型的响应式数据，那么推荐使用ref()。
>
>     ```{javascript}
>     import {ref} from 'vue';
>
>     export default{
>       setup(){
>         const title = ref("");
>         const one = ref(1);
>         const isValid = ref(true);
>         const foo = ref(null)
>       }
>     }
>     ```
>
>   - 我们使用ref()来实现上面Vue2中的响应式内容
>
>     ```{html}
>     <template>
>       <title>{{ title }}</title>
>     </template>
>     <script>
>       import {ref} from 'vue';
>                                                         
>       export default {
>         setup(){
>           const title = ref('title');
>                                                         
>           setTimeout(() => {
>             title.value = 'new title';
>           },5000);
>                                                         
>           return {title};
>         }
>       }
>     </script>
>     ```
>
>     ref()函数接收一个内部值，并返回一个响应式的对ref对象。ref对象具有一个属性value，这个value属性指向内部值。
>
>     如果想要访问或改变值，那么需要使用title.value
>
> - Ref拆箱
>
>   - 在上面的例子中，可以看到在模板中我们不需要使用ref对象的value属性就可以访问到ref对象的内部值。
>     - 当ref作为渲染上下文，也就是从setup()返回的对象，的属性返回并在模板中访问，那么它会自动展开为内部值，所以在模板中返回ref对象的内部值不需要引用ref对象的value属性。
>     
>     - 注意这里，computed属性也是一样，当在模板中使用计算属性的时候，我们不需要使用value属性来获取它的内部值，但是当在setup内部使用的时候，我们需要使用value属性来获取内部值
>     
>       ```{typescript}
>       setup(props,ctx){
>         const user = computed(() => {
>           return '111'
>         })
>         const isUser = computed(() => {
>           return '222' === user.value
>         })
>       }
>       ```
>     
>       
>
> - Reactive
>
>   - reactive()适合于创建响应式引用类型。
>
>     ```{html}
>     <template>
>       <title>{{ data.title }}</title>
>     </template>
>     
>     <script>
>       export default {
>         setup(){
>           const data = reactive({
>             title: 'title',
>           })
>           return {
>             data
>           };
>         }
>       }
>     </script>
>     ```
>
>     因为reactive()函数返回的是一个响应式的对象，当我们想要在模板中访问这个对象的中的属性的时候，需要使用data.title才可以访问或更改。
>     
>   - 在setup中如何修改reactive
>   
>     ```{html}
>     <template>
>       <title>{{ data.title }}</title>
>     </template>
>                                                                                                                 
>     <script>
>       export default {
>         setup(){
>           const data = reactive({
>             title: 'title',
>           })
>           data.title = 'title1'
>           return {
>             data
>           };
>         }
>       }
>     </script>
>     ```
>   
>     注意这里，reactive声明的响应式数据，如果我们想要在setup中修改它的值，那么不需要通过value属性来访问，直接访问它的属性就可以。

# 17.双向绑定和响应式数据的区别

> - 响应式数据
>   - 响应式数据的表现是响应式数据一旦更新，那么视图就会更新。
> - 双向绑定数据
>   - 双向绑定数据的表现是
>     - 双向绑定的数据一更新，视图就会更新。
>     - 如果视图更新，那么双向绑定的数据也会更新。
>   - 实际上双向绑定数据就是为响应式数据加上了一个事件触发，当视图改变，触发事件，那么事件处理函数就会修改双向绑定数据。
> - 响应式数据的实现原理
>   - 
> - 

# 18.TS中的接口

> - 写在之前
>
>   - 或许当我们只需要定义一个对象或类的时候，使用接口对它们进行约束是显得麻烦的，但是当我们需要定义具有同样结构的多个对象或类的时候，接口就体现出它的作用了。
>
> - 接口有什么作用，什么时候应该使用接口
>
>   - 定义
>
>     - 我们可以先看看接口的定义，接口是对某些数据或方法的约束规则。
>
>   - 其他面向对象编程语言中的接口
>
>     - 接下来我们可以先了解一下其他面向对象的语言，如C++中，接口的作用，在C++中，接口用于规定子类implements接口之后，必须实现接口中规定的变量和方法（相当于是对子类结构的约束）。
>
>   - C++中将接口也看成是一个类，class B : A，表示B派生自A，A是接口。
>
>     ![8671645181625_.pic](/Users/bytedance/Library/Containers/com.tencent.xinWeChat/Data/Library/Application Support/com.tencent.xinWeChat/2.0b4.0.9/213b5ee84790b0ae4c5b55978a6a2ae9/Message/MessageTemp/336f9314edccec2f03a268fad455eb07/Image/8671645181625_.pic.jpg)
>
>     C++中会将接口定义为虚函数。
>
>     如果需要提供一个getArea接口，那么需要在Shape类中将这个方法定义为虚函数，当class Rectangle派生自接口Shape，那么Rectangle类必须实现getArea这个方法。
>
>   - TS中的接口
>
>     - TypeScript中的接口是一个很灵活的概念，它相当于扩展了类似C++的面向对象编程语言中接口的行为。
>       - TS中的接口允许对类的结构进行约束。（类似于C++中规定了类中必须有哪些变量和方法）。
>       - TS中的接口也允许对对象（引用类型）的结构进行约束。（规定了对象中必须包含哪些属性）。
>
>   - 什么时候使用接口
>
>     - 当我们需要对引用类型的结构进行约束的时候可以使用接口。
>     - 当我们要声明多个类，我们可以首先定义一个接口用来规定这些类必须具有哪些变量、方法。
>
> - 使用接口对引用类型进行约束
>
>   - 约束对象
>
>     - 一个简单的例子
>
>       ```{typescript}
>       interface Person{
>         name: string;
>         age: number;
>       }
>       const person1: Person = {
>         name: 'aaa',
>         age: 1,
>       }
>       ```
>
>       接口一般首字母大写。我们首先定义了一个接口Person，然后定义了一个对象perosn1，并规定它的类型是Person，这样person1中就必须包含name属性和age属性了（必须不多也不少）。
>
>     - 如果对象中比接口少了一些属性
>
>       ```{typescript}
>       const person1: Person{
>         name: 'aaa',
>       }
>         // index.ts(6,5): error TS2322: Type '{ name: string; }' is not assignable to type 'Person'.
>       //   Property 'age' is missing in type '{ name: string; }'.
>       ```
>
>       我们可以看到当对象person1的类型是Person时，如果person1中没有包含Person中有的age属性，那么会出现报错。
>
>     - 如果对象中比接口多了一些属性
>
>       ```{typescript}
>       const person1: Person{
>         name: 'aaa',
>         age: 1,
>         gender: 'male',   
>       }
>       // index.ts(9,5): error TS2322: Type '{ name: string; age: number; gender: string; }' is not assignable to type 'Person'.
>       //   Object literal may only specify known properties, and 'gender' does not exist in type 'Person'.
>       ```
>
>       我们可以看到，当多出了Person接口中没有的属性的时候也会出现报错。
>
>     - 如果对象中的属性的类型和接口中的不一致
>
>       ```{typescript}
>       const person1: Person{
>         name: 123,
>         age: 1
>       }
>       //报错
>       ```
>
>       当person1对象中的属性name的类型和Person接口中定义的不一致的时候，也会报错。
>
>     - 可选的属性
>
>       ```{typescript}
>       interface Person{
>         name: string;
>         age?: number;
>       }
>       const person1: Person{
>         name: 'aaa',
>       }
>       ```
>
>       使用 ？我们可以定义可选属性，如上面的例子中，age就是一个可选属性，表示以Person接口为类型约束的对象可以包含age属性，也可以不包含age属性。
>
>     - 任意属性
>
>       ```{typescript}
>       interface Person{
>         name: string;
>         age?: number;
>         [key: string]: any;
>       }
>       const person1: Person = {
>         name: 'aaa',
>         gender: 'male',
>       }
>       ```
>
>       上面的例子中，接口Person通过[key: string]表示key是string类型的，:any表示值可以是任何类型的。
>
>     - 任意属性的常见错误
>
>       ```{typescript}
>       interface Person{
>         name: string;
>         age?: number;
>         [key: string]: string;
>       }
>       const person1: Person = {
>         name: 'aaa',
>         gender: 'male',
>       }
>       // index.ts(3,5): error TS2411: Property 'age' of type 'number' is not assignable to string index type 'string'.
>       // index.ts(7,5): error TS2322: Type '{ [x: string]: string | number; name: string; age: number; gender: string; }' is not assignable to type 'Person'.
>       //   Index signatures are incompatible.
>       //     Type 'string | number' is not assignable to type 'string'.
>       //       Type 'number' is not assignable to type 'string'.
>       ```
>
>       报错的原因是[key: string]: string同样会对上面的其他属性，如age?: number进行检查，很显然，age?: number不满足[key: string]: string的要求。
>
>     - 只读属性
>
>       ```{typescript}
>       interface Person{
>         readonly id: number;
>         name: string;
>         age?: number;
>         [key: string]: any;
>       }
>       const person1: Person = {
>         id: 89742435,
>         name: 'aaa',
>         gender: 'male',
>       }
>       person1.id = 111;
>       // index.ts(14,5): error TS2540: Cannot assign to 'id' because it is a constant or a read-only property.
>       ```
>
>       我们可以使用readonly关键字声明某一个属性是只读的。这样以Person接口为类型约束的对象不能在初始化后修改id这个属性。
>
>   - 使用接口约束函数
>
>     - 一个简单的例子
>
>       ```{typescript}
>       interface encrypt{
>         (key: string,val: string): string;
>       }
>       var md5: encrypt = function(key: string,val: string): string{
>         ...
>         return 'aaa';
>       }
>       ```
>
>       
>
>     - 
>
>   - 
>
> - 

# 19. React事件处理函数 和 作为props传入子组件的处理函数的不同

> - 问题描述
>
>   - 有时候我们会遇到事件处理函数的入参不知道从哪里来的的情况
>
>     ```{jsx}
>     class Calculator extends React.Component {
>       constructor(props) {
>         super(props);
>         this.handleCelsiusChange = this.handleCelsiusChange.bind(this);
>         this.handleFahrenheitChange = this.handleFahrenheitChange.bind(this);
>         this.state = {value: '', scale: 'c'};
>       }
>                                                           
>       handleCelsiusChange(value) {
>         this.setState({scale: 'c', value});
>       }
>                                                           
>       handleFahrenheitChange(value) {
>         this.setState({scale: 'f', value});
>       }
>                                                           
>       render() {
>         const scale = this.state.scale;
>         const value = this.state.value;
>         const celsius = scale === 'f' ? tryConvert(value, toCelsius) : value;
>         const fahrenheit = scale === 'c' ? tryConvert(value, toFahrenheit) : value;
>                                                           
>         return (
>           <div>
>             <TemperatureInput
>               scale="c"
>               value={celsius}
>               onChange={this.handleCelsiusChange} /> <!-- 我们可以看到这里完全没有为这个函数传入参数，但是却可以正常执行 -->
>             <TemperatureInput
>               scale="f"
>               value={fahrenheit}
>               onChange={this.handleFahrenheitChange} />
>             <BoilingVerdict
>               celsius={parseFloat(celsius)} />
>           </div>
>         );
>       }
>     }
>     ```
>
> - 事件处理函数
>
>   - 事件处理函数的调用方式
>
>     ```{javascript}
>     handleEvent(e){
>       this.setState({value: e.target.value});
>     }
>     ...
>     onChange={handleEvent(event)} //在这里传入参数才是事件处理函数的调用方法。
>     ```
>
> - 作为props传入子组件的函数
>
>   - 有时候我们也可以将函数作为props传入子组件中，如这个函数的参数需要在子组件中访问的时候。（这种使用方式的函数也像普通函数一样，最好先使用bind绑定了this对象）。
>
>     ```{javascript}
>     <TemperatureInput
>       scale="c"
>       value={celsius}
>     	onChange={this.handleCelsiusChange} />
>     ```
>
>     这段代码中的 this.handleCelsiusChange实际上是将函数handleCelsiusChange传入了组件\<TemperatureInput />中，这样在子组件中就可以通过this.props.onChange来访问这个函数
>
>     ```{jsx}
>     class TemperatureInput extends React.Component {
>       //...
>                                                           
>       handleChange(e) {
>         this.props.onChange(e.target.value);
>       }
>                                                           
>       render() {
>         //...
>         return (
>           <fieldset>
>             <legend>Enter temperature in {scaleNames[scale]}:				 </legend>
>             <input value={value}
>                    onChange={this.handleChange} />
>           </fieldset>
>         );
>       }
>     }
>     ```
>
> - 造成误解的原因
>
>   - 在这里造成误解的原因是父组件中将props的名称写的和onChange一样，为了避免误会，也可以写成parentMethod={ ... }，效果一样。

# 20.后花园登录方法以及端口占用解决方法

> - 后花园登录方法
>
>   - 当需要在本地调试后花园的时候，不登录是没有数据的，没有数据就很难调试。这时候我们就需要做登录操作，在本地的时候，进入localhost这个地址，将端口改为3000，登录url为：localhost: 3000/login
>
> - 端口占用解决方法
>
>   - 当3000端口被占用的时候，我们是无法完成登录操作的，这时候就需要将占用3000端口的所有进程杀掉。
>
>     - 使用 
>
>       ```shell
>       lsof -i:3000
>       ```
>
>       占用3000端口的进程，在这里可以看到PID（lsof命令是linux中查看指定端口被哪个进程占用的命令）
>
>     - ```shell
>       kill -9 PID
>       ```
>
>       表示彻底杀掉指定PID的进程
>
> - 如果出现TS错误
>
>   - 删掉server下面的typings的auto-genertaed，再运行dev命令。

# 21.import和require

> - 写在之前
>
>   - import和require都是JS模块化编程使用的，用于提升前端性能。
>
> - 对模块化的理解
>
>   - 模块化主要是将一整个系统拆分成各个独立的部分。
>   - 一个模块是完成某一个功能的一段代码（可以和组件相比较理解）。
>   - 在JAVA中模块化是将实现某个功能的一段代码封装成一个类，但是因为JavaScript中没有类（至少ES6之前没有类），因此JS借助了对象或构造函数来模拟类进而实现模块化。
>   - 在webpack中，一个图片，一个CSS文件等都是一个module（模块）。
>   - 一个模块有着独立的作用域，模块内部定义的变量外部是无法获取的。·
>
> - 引入规范
>
>   - require/exports是commonJS引入。（commonJS默认导出的是一个对象）。
>   - import/export是ES6引入。（因为存在浏览器兼容问题，需要在node中使用babel将ES6语法编译成ES5）。
>
> - 调用时间
>
>   - require是运行时调用，所以可以放在代码的任何地方。
>   - import是编译时调用，所以必须放在文件开头。（因为编译时会做语法检查）
>
> - 本质
>
>   - require是赋值过程，它实际上就是RHS赋值。（值传递）。
>   - import是解构过程，使用import导入模块的属性或方法是引用传递（将地址传入）。
>
> - 语法用法展示
>
>   - require用法
>
>     - 将模块A中要导出的数据放入module的exports属性中，假设模块B中要使用导出的这部分内容，那么可以在模块B中使用require导入，这时就会导出模块A中的exports属性并在模块B中执行RHS赋值操作。（执行浅拷贝）。
>
>       这里是模块A（module.export相当于export default）
>
>       ```{typescript}
>       module.exports = {
>         a: function() {
>           console.log('exports from module');
>         }
>       }
>       ```
>
>       这里是模块B
>
>       ```{typescript}
>       const obj = require('./moduleA.ts');
>       obj.a() //exports from module
>       ```
>
>     - 当我们不需要导出模块A中的全部内容的时候
>
>       ```{typescript}
>       module.exports = {
>         test: function(){
>           console.log('test');
>         },
>         a: function(){
>           console.log('exports from module')
>         }
>       }
>       ```
>
>       ```{typescript}
>       const { test } = require('./moduleA.ts');
>       ```
>
>       我们使用解构赋值，使用大括号包裹住要导出的部分。
>
>   - import用法
>
>     - 使用import导出的值和模块中的值始终保持一致，也就是引用拷贝，import采用解构赋值结合export使用。
>
>     - 使用export关键字标记要导出的内容，当test.js中需要导入这部分内容的时候，使用import，这时export就会将标记的内容导出，病执行引用传递（地址传递）。
>
>       - 这里是文件module.js
>
>       ```{typescript}
>       export function test(args){
>         console.log(args);
>       }
>       export default{
>         a: function(){
>           console.log('export from module');
>         }
>       }
>       export const name = 'aaa';
>       ```
>
>       - 这里是文件test.js
>
>       ```{typescript}
>       import _, { test, name} from './module.js'
>       ```
>
>       在test.js中，我们使用 _ 导出export default的内容。同时我们注意到，不是使用默认导出的话，import的时候就需要使用一样的模块名称。（同时当不是默认导出的时候，为了导出同名模块，需要使用解构赋值）。
>
>       ```{typescript}
>       import module from './module.js'
>       ```
>
>       也可以这样导出默认导出的内容。
>
>       ```{typescript}
>       import {module as moduleA} from './module.js'
>       ```
>
>       当出现有命名重复的时候，那么我们需要用到ES6中的对模块重命名的语法。上面是将module重命名为moduleA。

# 22.Array.prototype.map和Array.prototype.forEach的区别

> - map
>
>   - map的作用是创建一个新数组，这个数组的元素是原数组的每个元素调用一次提供的函数的结果。
>
> - forEach
>
>   - forEach的作用是遍历一遍数组，然后对每个元素执行提供的函数。
>
>     - forEach不会创建新数组。
>
>     - forEach类似于for循环，但是如果想要在forEach提供的函数中修改原数组的元素，必须使用arr[index]
>
>       ```{javascript}
>       const array1 = [1, 2, 3];
>                                                                                                                   
>       array1.forEach((element,index,arr) => arr[index] = element * 2);
>       console.log(array1) //原数组改变了
>       ```
>
> - 总结
>
>   - map和forEach都可以作为遍历数组并执行提供的函数的作用。
>   - 但是由于map的不变性，在不想改变原数组的情况下，推荐使用map。

# 23.副效应、useEffect、useMemo、useCallback

> ![截屏2022-02-22 下午7.49.02](/Users/bytedance/Desktop/截屏2022-02-22 下午7.49.02.png)
>
> - 副效应（纯函数只能涉及数据计算，其他操作都是副效应）
>
>   - 在函数式编程中，将只利用输入通过一系列计算得到输出的函数叫做纯函数，而如果函数中需要改变外部状态，如修改一个变量的值，那么这部分代码是函数中的副效应。
>   - React hook的作用就是利用hook来为纯函数添加副效应。
>
> - useEffect
>
>   - useEffect是最常用的React hook，它包含有2个参数，第一个是一个effect函数，第二个参数可选，是一个数组（数组中可以填入effect函数的依赖项）。
>
>     ```{typescript}
>     useEffect(() => {
>       ...
>     },[...])
>     ```
>
>     effect中一般是包含副效应的函数。
>
>   - 当useEffect的第二个参数不选的时候，useEffect中的effect函数的执行逻辑
>
>     ```{typescript}
>     useEffect(() => {
>       ...
>     })
>     ```
>
>     这时，当页面每一次重新渲染，effect函数都会执行一次。
>
>   - 当useEffect的第二个参数不为空数组（注意当有多个副效应，那么就用多个useEffect）（这里在页面渲染完成也会执行一次）
>
>     ```{typescript}
>     useEffect(() => {
>       ...
>     },[a])
>     ```
>
>     这时，当变量a改变时，effect函数才会执行。
>
>   - 当useEffect的第二个参数是空数组的时候
>
>     ```{typescript}
>     useEffect(() => {
>       ...
>     },[])
>     ```
>
>     这时，useEffect的effect函数只会执行一次（在页面渲染完成执行）。
>
> - useCallback
>
>   - useCallback也是hook中较为常用的，它的语法形式与执行逻辑类似于useEffect，但是作用类似于useState。
>
>     ```{typescript}
>     const fetchData = useCallback(() => {
>       ...
>     }, []);
>     ```
>
>   - useCallback的第一个参数是我们之后要使用的函数（大概率是后面代码中useEffect中的依赖项），第二个参数是一个数组。
>
>     - 在上面的代码中，useCallback会将第一个参数赋给fetchData保存起来。
>
>   - useCallback的执行逻辑和useEffect类似
>
>     - useCallback的执行逻辑取决于第二个可选参数。
>     - 当没有传第二个参数的时候，useCallback会在每次页面渲染后执行。
>     - 当传入的第二个参数是非空数组的时候，useCallback会在依赖项发生变化的时候执行。
>     - 当传入的第二个参数是一个空数组的时候，useCallback只会执行一次。
>
>   - useCallback什么时候使用，解决了什么问题
>
>     - 当我们需要在代码中加入useEffect并且依赖项是某个函数的时候，我们可以使用useCallback将这个函数固定下来。（useCallback更常见于将某个函数作为回调传给子组件）。
>
>       ```{tsx}
>       function App(){
>         const [val, setVal] = useState(0);
>                                                                                                                                                                           
>         function getData() {
>           setTimeout(() => {
>             setVal(val + 1)
>           },500)}
>                                                                                                                                                                             
>           useEffect(() => {
>             getData();
>           },[getData])
>                                                                                                                                                                           
>         return {
>           <h1>{val}</h1>
>         }
>       }
>       ```
>
>       上面这种写法会造成下列死循环
>
>       1.组件App渲染时，生成getData函数，由于useEffect中对getData有依赖，因此会执行useEffect第一个参数中的effect函数。
>
>       2.effect函数调用getData函数，getData函数中调用了setVal，修改了val，触发组件App重新渲染。
>
>       3.App重新渲染时生成了新的getData方法
>
>       4.useEffect发现getData引用发生改变，因此再次执行effect函数。
>
>       ```{typescript}
>       function App(){
>         const [val, setVal] = useState(0);
>                                                                                                                                                                           
>         function getData() {
>                                                                                                                                                                             
>           const getData = useCallback(() => {
>             setTimeout(() => {
>               setVal(val + 1)
>             },500)
>           },[])
>                                                                                                                                                                             
>           useEffect(() => {
>             getData();
>           },[getData])
>                                                                                                                                                                             
>         return {
>           <h1>{val}</h1>
>         }
>       }
>       ```
>
>       使用useCallback来将需要作为依赖项的函数getData赋给变量getData保存，这样就不会触发死循环。
>
>       
>
> - useMemo（主要用来提升性能，当依赖项不变化时，不会重新计算）
>
>   - 写在之前
>
>     - 其实useMemo应该写在useCallback之前，毕竟useCallback实际上是useMemo的一种特殊情况，当useMemo要保存的value是函数的时候，那么实际上就是useCallback，但是因为函数写在useMemo中看上去很奇怪，所以使用了useCallback。
>
>   - useMemo包含2个参数，第一个参数是一个函数，第二个参数是依赖项数组。
>
>     ```{typescript}
>     const val = useMemo(() => {
>       ...
>       return value
>     },[])
>     ```
>
>     
>
>   - useMemo实际上类似于Vue的Option API中的computed，给定函数和依赖项，当依赖项不发生改变的时候，函数不会重新计算。同时变量中保存的值是函数的return。
>
>   - useMemo是不能传参数的。
>
>   - useMemo和useEffect的区别
>
>     - 因为useMemo实际上是计算属性，就必然在渲染前执行，而useEffect用于执行副效应，所以放在渲染后执行。

# 24.TS中定义函数类型

> - 写在之前
>
>   - TS对JS函数的修改是，为JS函数增加了强类型语言（C++等）函数的用法。
>
> - 如何定义一个函数类型
>
>   - 基础用法
>
>     ```{typescript}
>     function add(x: number, y: number): number{
>       return x + y;
>     }
>     ```
>
>     上面的例子中，规定了函数add的第一个参数类型必须是number，第二个参数的类型必须是number，以及函数的返回值的类型必须是number。
>
>     我们也可以不定义函数的返回值类型，因为TS类型检查系统会对返回值进行类型推断。
>
>     ```{typescript}
>     function add(x: number, y: number){
>       return x + y;
>     }
>     ```
>
>     上面的例子中就没有为函数的返回值规定类型，但是TS类型检查会帮我们完成。
>
>   - 为剪头函数定义类型
>
>     ```{typescript}
>     const add = (x: number,y: number): number => {
>       return x + y;
>     } 
>     ```
>
>     
>
>   - 当没有提供函数实现时，对函数类型进行声明的方法
>
>     ```{typescript}
>     interface addFunc{
>       (x: number,y: number): number;
>     }
>     interface obj{
>       add?: (x: number,y: number) => number;
>     }
>     ```
>
>     上面的例子中给出了2种直接为函数类型提供声明的方法，注意这里我们利用了interface，interface是可以用于约束引用类型和类的类型的。
>
>     ```{typescript}
>     const secondAdd: addFunc
>     secondAdd = function(x,y){
>       return x + y;
>     }
>     ```
>
>     因为上面我们已经对函数类型进行了规定，这样我们在写函数实现的时候就不需要再进行类型规定。
>
> - 可选参数
>
>   - 尽管我们在上面定义了函数形参每个参数的类型，但是为了实现函数重载，我们还可以引入可选参数（函数重载在C++中是指，声明多个功能相似的同名函数，但是这些同名函数的形参（个数、顺序、类型）中至少一个必须不同）。
>
>     ```{typescript}
>     function times(x: number,y?: number){
>       if(y){
>         return x* y;
>       }
>       return x;
>     }
>     ```
>
>     在上面的例子中，我们定义了可选参数，这样就既可以传入一个参数，也可以传入2个参数。同时传入不同个数参数时，执行逻辑不同，这样就实现了利用参数个数不同的函数重载。
>
> - 剩余参数
>
>   - ES6中提出了剩余参数的概念，TS在这个的基础上加了类型校验。
>
>     ```{typescript}
>     function add(x: number, ...restNums: number[]){
>       let res = x;
>       for(let i = 0;i < restNums.length;i++)
>       {
>         res = res + restNums[i];
>       }
>       return res;
>     }
>     add(1,2,3) // 6
>     add(1,2,3,4,5) //15
>     ```

# 25.not伪类和not伪类不支持群组选择器的解决方法

> - not伪类
>
>   - not伪类的是为了解决不选中某个指定元素。
>
>   - 语法
>
>     ```{css}
>     .nav-item.link-item a:not(.no-before){
>       ...
>     }
>     ```
>
>     
>
> - 什么时候使用not伪类
>
>   - 在上面的例子中，我们可以看到，当我们一次性选中一系列元素想要为它们设置相同的样式的时候，但是有1个或2个元素不需要被统一设置样式，这时我们可以使用not伪类来不选中某个元素。
>
> - not伪类不支持群组选择器的解决方法
>
>   - not伪类中写群组选择器是没有得到广泛支持的。
>   - 但是如果想要同时不选中多个元素的话，可以为这些元素加上一个相同的类选择器。

# 26. 轻服务与nodejs踩坑综合记

> - 关于当想使用一个数组作为接口的request params，想使用这个数组从数据库中查出所有对应的observations的方法。
>
>   - 一个例子
>
>     - 当我们传入的是一个由要查询的observations的id字段组成的数组
>
>       ```{JSON}
>       {
>         "idList": [
>           "2375360734846391",
>           "1495755366941576",
>           "1600525133428039",
>           "1846782829803550"
>         ]
>       }
>       ```
>
>     - 目的是从数据库中查出所有对应id字段的observation
>
>   - 针对这个例子，利用轻服务提供的where完成查询的方法
>
>     - 需要注意的是，轻服务的where不接受直接提供数组
>
>       ```{Javascript}
>       const resList = await table.where(idList).find(); //这样是查不成功的。
>       ```
>
>       
>
>     - 首先，我们可以想到一个简单的方法——for循环
>                                                                                                            
>       ```{javascript}
>       const resList = [];
>       for(let i = 0;i < idList.length;i++)
>       {
>         const list = await table.where({id: idList[i]}).find();
>         resList.push(...list);
>       }
>       ```
>                                                                                                            
>       但是明显的缺陷无法利用API一次性从数据库查出数据，需要很多次数组操作
>                                                                                                            
>     - 接下来，我们尝试是否可以使用一些取巧的方法一次性查询所有数据。
>                                                                                                            
>       - 首先我们注意到，轻服务的whereAPI支持传入一个函数
>                                                                                                            
>         ```{javascript}
>         function query(idList){
>           return idList.includes(this.id);
>         }
>         const list = await table.where(query(idList)).find()
>         ```
>                                                                                                            
>         但是我们尝试之后，很快发现是不行的，错误在于，一旦传入参数，那么函数中的this就不再指向数据中的observation了
>                                                                                                            
>       - 为了不传入参数，但是可以引用到idList，我们很容易想到使用闭包
>                                                                                                            
>         ```{javascript}
>         function query(idList){
>           return function(){
>             return idList.includes(this.id)
>           }
>         }
>         const list = await table.where(query(idList)).find();
>         ```
>                                                                                                            
>         闭包可以让传入where的闭包函数在即使外层函数已经执行完毕被销毁的情况下，依旧可以访问到外层函数作用域中的变量。
>                                                                                                            
>         但是我们发现由于轻服务对闭包变量进行了处理，使内部函数无法访问到闭包变量。
>                                                                                                            
>       - 接下来，经过再次仔细阅读文档，我们可以发现，轻服务中如果想要查询多个filter的话
>                                                                                                            
>         ```{javascript}
>         const list = await table.where(db.or(filter1,filter2,...)).find();
>         ```
>                                                                                                            
>         这样我们似乎可以将多个filter组成一个数组，利用展开运算符传入db.or()
>                                                                                                            
>         ```{javascript}
>         function query(list){
>           const filterList = list.map((item) => {return {id: item}});
>           return filtereList;
>         }
>         const list = await table.where(db.or(...query(idList));
>         ```
>                                                                                                            
>         很快，最终使用这个方法成功了。

# 27.Object.defineProperty()

>  

​        '/faas/*': {

​          target: 'https://cloudapi.bytedance.net',

​          changeOrigin: true,

​          ws: false,

​        },

# 28.Vue的transition组件和transition group组件

> - 使用\<transition>的时机，为什么使用\<transition>，\<transition>的实现原理
>
>   - 首先我们需要理解\<transition>有什么作用
>
>     - \<transition>组件用于给某个元素或组件添加过渡动画效果，只需要用\<transition>把该元素或组件包裹起来，就可以封装成过渡组件。
>
>       ```{jsx}
>       <transition name="fade">
>       	<my-component></my-component>
>       </transition>
>       ```
>
>   - \<transition>的过渡效果出现时机
>
>     - vue只有在插入、更新、移除DOM元素时，才会触发过渡效果
>     - 所以只有在被插入、更新、移除的时候，封装成过渡组件才会出现过渡效果。
>
>   - \<transition>过渡效果的实现原理
>
>     - \<transition>的过渡效果的实现原理有2种
>       - 利用CSS transition或animation来实现
>       - 利用JavaScript钩子函数来实现
>     - 也就是说，我们使用过渡组件也需要使用CSS或JavaScript来为它定义过渡效果。
>
>   - 过渡组件的过渡效果的执行逻辑
>
>     - 当有一个过渡组件A被插入、更新、移除后，会经过以下3步
>       - 第一步，首先Vue会去查找过渡组件是否定义了CSS transition或animation效果，如果有的话，就会执行CSS定义的过渡效果。
>       - 第二步，如果过渡组件没有设置CSS效果，那么Vue会去查找过渡组件是否设置了JavaScript钩子函数，如果有，会执行钩子函数定义的过渡效果。
>       - 第三步，如果CSS和钩子函数都没有设置，那么不会展示过渡效果。（这时和未被\<transition>包裹一样）。
>
> - \<transition>的使用方法（CSS为例。命名\<transition>会自动生成6个类供我们控制过渡效果）
>
>   - 如果我们想要使用一个\<transition>组件包裹而成的过渡组件，那么我们需要为\<transition>设置一个name属性。
>
>     ```{jsx}
>     <transition name="fade">
>       <my-component></my-component>
>     </transition>
>     ```
>
>   - 这样在组件过渡的过程中，会具有以下6个类名以供我们控制过渡效果
>
>     这里我们将过渡过程分成2种：进入过渡（元素插入后进入过渡，一直到过渡效果完成结束）；离开过渡（元素移除后进入离开过渡，过渡效果完成结束）
>
>     - xxx-enter（fade-enter），进入过渡的开始状态，元素被插入时生效，只应用一帧后立刻删除。
>     - xxx-enter-active（fade-enter-active），进入过渡的整个过程，元素被插入时生效，过渡过程完成后被移除。
>     - xxx-enter-to（fade-enter-to），进入过渡的结束部分，在元素被插入后下一帧生效（这时xxx-enter被移除），在过渡效果完成后被移除。
>     - xxx-leave（fade-leave），离开过渡的开始阶段，元素被删除时触发，只生效一帧后删除。
>     - xxx-leave-active（fade-leave-active），离开过渡的整个阶段，元素被删除时生效，离开过渡完成时结束。
>     - xxx-leave-to（fade-leave-to），离开过渡的结束阶段，在离开过渡被触发后一帧生效（同时xxx-leave被移除），在过渡完成之后移除
>
>     ![截屏2022-03-02 下午4.56.43](/Users/bytedance/Desktop/截屏2022-03-02 下午4.56.43.png)
>
> - 自定义过渡类名
>
>   - 自定义过渡类名是什么
>
>     - 当我们对\<transition>做了命名，那么会根据name属性自动生成。但是我们也可以通过为\<transition>定义以下6个属性来定义类似于上面6个类名的自定义类名
>       - enter-class，对标xxx-enter
>       - enter-active-class，对标xxx-enter-active
>       - enter-to-class，对标xxx-enter-to
>       - leave-class，对标xxx-leave-class
>       - leave-active-class，对标，xxx-leave-active
>       - leave-to-class，对标xxx-leave-to
>
>     ```{jsx}
>     <transition name="fade" 
>       enter-class="fade-enter" 
>       enter-active-class="fade-in-active"
>       enter-to-class="fade-in-to"
>       leave-class="fade-leave"
>       leave-active-class="fade-out-active"
>       leave-to-class="fade-out-to"
>       >
>       <my-component></my-component>
>     </transition>
>     ```
>
>     
>
>   - 为什么需要自定义过渡类名，自定义过渡类名的作用，什么时候使用自定义过渡类名
>
>     - 自定义过渡类名优先级高于普通类名，在混合使用外部组件的时候会比较有用。
>
> - 如何指定过渡持续时间
>
>   - 为什么需要指定过渡持续时间，指定过渡持续时间的作用
>
>     - 大多数时候，使用Vue自动得出的过渡持续时间就可以达到预期效果，但有时候，我们需要手动控制整个过渡时间的持续时间、控制进入过渡的持续时间、控制离开过渡的持续时间
>
>   - 指定过渡持续时间的方法（毫秒为单位）
>
>     ```{jsx}
>     <transition :duration="1000">
>       <my-component></my-component>
>     </transition>
>     ```
>
>     ```{jsx}
>     <transition :duration="{enter: 500, leave: 800}">
>       <my-component></my-component>
>     </transition>
>     ```
>
>     第二个例子中，我们分别指定了进入过渡和离开过渡的持续时间。

> - 为什么需要\<transition-group>组件
>
>   - \<transition-group>组件和\<transiiton>组件的区别，为什么还需要\<transition-group>组件
>
>     - 在上面我们学习的\<transiiton>组件只能实现针对单一元素、组件的过渡效果。
>
>     - 但是有时候，我们需要当操作列表，对列表某个元素进行删除时，也可以有过渡效果，这时就需要使用\<transition-group>组件
>
>       （使用\<transiiton>组件对 列表li 设置过渡效果是不生效的）
>
> - \<transition-group>组件特点
>
>   - \<transition-group>组件会以一个真实元素呈现，默认为一个 span 标签，也可以通过 tag 属性来更换为其他元素。
>   - 内部元素总是需要提供唯一的 key 属性
>   - CSS过渡的类将会应用在内部的元素，而不是这个列表
>
> - \<transition-group>组件使用方法
>
>   - \<transition-group>组件也是使用同样的类名来定义过渡效果。
>
>     ```{vue}
>     <template>
>       <div>
>         <ul>
>           <transition-group name="list">
>             <li v-for="item in items" :key="item.user_id">					</li>
>           </transition-group>
>         </ul>
>       </div>
>     </tempale>
>     ```
>
>     1. XXX-enter
>     2. XXX-enter-to
>     3. XXX-enter-active
>     4. XXX-leave
>     5. XXX-leave-to
>     6. XXX-leave-active

# 29.当遇到类型可能是undefined或null的值，如何放入includes方法

> - 一个例子
>
>   ```{typescript}
>   let data: string | undefined
>   ```
>
>   对于类型声明是string或undefined的时候，如果我们直接将data放入Array.prototype.includes，那么将会有类型错误。
>
>   ```{typescript}
>   const arr: Array<string> = ['a']
>   arr.includes(data || '')
>   ```
>
>   这样为includes提供一个默认值，就可以规避类型检查错误。

# 30.当控制台遇上异步数据

> - 同步和异步
>
>   - 首先我们来回顾一下JS的同步和异步的执行逻辑
>
>     - JS利用事件循环规定了同步和异步的执行逻辑
>
>       1. 执行栈和事件队列
>
>          - 执行栈：当主线程在执行过程中遇到同步代码，会按照顺序添加到执行栈。
>
>            ```{javascript}
>            function a(){
>              b();
>              console.log('a');
>            }
>            function b(){
>              console.log('b');
>            }
>            a()
>            ```
>
>            上面的实例代码中，执行栈的变化如下
>
>            1. 首先要执行函数a，所以函数a入栈
>            2. 函数a中首先要执行函数b，所以函数b入栈
>            3. 执行函数b，console.log('b')入栈
>            4. console.log('b')执行完毕，出栈
>            5. 函数b执行完成，出栈
>            6. console.log('a')入栈
>            7. console.log('a')执行完，出栈
>            8. 函数a出栈
>
>          - 事件队列：当主线程在执行过程中遇到异步代码，主线程不会等待异步代码执行，而是会将异步代码挂起，当异步代码（如，网络请求）得到结果之后，会将它的回调放入事件队列，等待主线程清空执行栈之后，主线程会去事件队列中查找是否存在任务，如果存在，那么主线程将从事件队列队头取出任务，将它的回调放入执行栈，主线程会开始执行它的同步代码
>
>            注意实际上，不同的异步任务将被放入不同的异步任务队列（宏任务队列和微任务队列）
>
>            ```{javascript}
>            function a(){
>              b();
>              console.log('a');
>            }
>            function b(){
>              console.log('b');
>              setTimeout(function() {
>                console.log('c');
>              }, 2000)
>            }
>            a()
>            ```
>
>            
>
>       2. 宏任务和微任务
>                                                                                                            
>          - 什么是宏任务和微任务
>            - 异步任务被分为2种：宏任务和微任务，实际上它们俩都是异步任务。
>          - 为什么要把异步任务划分为2种
>            - 因为异步任务实际上是存在优先级的，如果所有异步任务都是一种，那么主线程将按顺序从队头取出任务放到执行栈执行。
>          - 有哪些宏任务
>            - script(整体代码)
>            - setTimeout()
>            - setInterval()
>            - postMessage
>            - I/O
>            - UI交互事件
>          - 有哪些微任务
>            - Promise().then中的回调
>            - MutationObserver
>                                                                                                            
>       3. 一个（浏览器）事件循环的过程（执行一个宏任务，并清空所有微任务）
>                                                                                                            
>          1. 第一步，主线程去宏任务队列中取出<strong>一个</strong>宏任务放入执行栈，直到清空宏任务队列
>                                                                                                            
>             （在这个过程中，如果主线程遇到异步代码，那么会等待它们得到结果后按照分类放入不同的异步队列）
>                                                                                                            
>          2. 第二步，当这个宏任务执行完毕，出栈，主线程会去查看微任务队列是否存在任务，如果存在微任务，那么主线程将清空微任务队列
>
> - 当想使用console.log打印异步数据
>
>   - 一个例子
>
>     ```{javascript}
>     let obj = {
>       a: 1,
>     }
>     console.log(obj)
>     obj.a++
>     ```
>
>     在上面的例子中，我们直觉的认为，打印出的obj中的a是1，但是实际上
>
>     ![截屏2022-03-03 下午4.12.20](/Users/bytedance/Desktop/截屏2022-03-03 下午4.12.20.png)
>
>   - 导致问题的原因
>
>     - 上面例子的执行逻辑
>       1. 当主线程执行到console.log(obj)，浏览器会立即使用JSON.stringify，将对象序列化为一个字符串来展示
>       2. 主线程会继续执行，当执行到obj.a++，所以这时对象obj中的a属性的值变为2
>       3. 当我们去点开obj这个打印内容，这时浏览器就会去对象obj的地址读取当前a属性的值，所以这时就变成了2

# 31.组件间通信的方法

> - 发出事件
>
>   - 组件A(发出自定义事件XXX)
>
>     ```{typescript}
>     const eventBus = this.$getBean<EventBus>('eventBus')
>     eventBus.emit(eventBus.eventType.XXX,param1,param2)
>     ```
>
>     eventBus.emit()方法的第一个参数是触发的自定义事件名，后面可以接可选个数的参数，将传递给接收自定义事件的处理函数。
>
> - 接收事件
>
>   - 组件B(接收自定义事件XXX)
>
>     ```{typescript}
>     mounted(){
>       const eventBus = this.$getBean<EventBus>('eventBus')
>       eventBus.onVmLife(
>         this as any,
>         eventBus.eventType.XXX,
>         (param1,param2) => {
>         	...
>       	}
>       )
>     }
>     ```
>     
>   - 在setup()钩子函数中，eventBus.onVmLife的第一个参数（当前实例）获取方法（使用getCurrentInstance.proxy）
>   
>     ```{typescript}
>     setup(props,{ root }){
>       const instance = getCurrentInstance?.proxy;
>       const eventBus = root.$getBean<EventBus>('eventBus');
>                                                                                                   
>       onMounted(() => {
>         eventBus.onVmLife(
>           instance as any,
>           eventBus.eventType.XXX,
>           (param1,param2) => {
>             ...
>           }
>         )
>       })
>     }
>     ```
>   
>     

# 32.v-if遇到setTimeout(() => {emit('xxx')},0)

> - 一个例子
>
>   - 当我们需要在父子组件间通信时候，我们需要使用emit
>
>   - 子组件
>
>     ```{typescript}
>     setup(props,{emit}){
>       function handleClick(){
>         emit('XXX')
>       }
>     }
>     ```
>
>     这时当子组件中触发了点击事件，调用handleClick函数之后，将会发送自定义事件XXX到父组件
>
>   - 父组件
>
>     ```{jsx}
>     <SubComponent v-if="isVisblie" @XXX="onSubClick" v-click-outside="handleClickOutside">
>     </SubComponent>
>     ...
>     function handleClickOutside(){
>       this.isVisblie = false
>     }
>     function onSubClick(){
>       console.log('ok')
>     }
>     ```
>
>     父组件会调用onSubClick方法，打印出 ok
>
> - 当这个例子中子组件使用了setTimeout
>
>   - 子组件
>
>     ```{typescript}
>     setup(props,{emit}){
>       function handleClick(){
>         setTiemout(() => {emit(XXX)},0)
>       }
>     }
>     ```
>
>     这时将emit放入setTimeout中，将会在下轮事件循环中emit出这个自定义事件XXX
>
>   - 父组件
>
>     ```{jsx}
>     <SubComponent v-if="isVisblie" @XXX="onSubClick" v-click-outside="handleClickOutside">
>     </SubComponent>
>     ...
>     function handleClickOutside(){
>       this.isVisblie = false
>     }
>     function onSubClick(){
>       console.log('ok')
>     }
>     ```
>
>     由于存在v-click-outside，而子组件中的点击事件会出发clickoutside，所以在本轮事件循环结束之前，SubComponent已经被销毁了，所以自定义事件XXX的处理函数也就无法执行
>
> - 为什么不加setTimeout就可以正常执行
>
>   - 首先我们回顾一下Vue的异步更新队列
>
>     - Vue在观察到数据变化时并不会直接更新DOM，而是会开启一个队列，并将同一事件循环中发生的所有数据改变放入这个队列
>
>       - 为什么需要这个队列
>
>         Vue会在同一事件循环中不断维护这个队列，以此去除重复的改变，避免进行不必要的DOM操作和计算。
>
>     - 等到本轮事件循环末尾，或下一轮事件循环开启的时候（这取决于Vue采用哪种方法，Vue优先采用Promise.then，但是如果浏览器不支持，Vue会采用setTimeout）
>
>   - 异步更新队列如何解释上面的错误
>
>     - 当没有在子组件中加入setTimeout的时候，emit方法将在本轮事件循环中执行，这时，虽然触发emit的点击事件虽然已经将isVisblie更改为false，但是Vue会将销毁SubComponent放入异步更新队列，所以当emit被触发的时候SubComponent还没有被销毁。
>     - 当在子组件中加入setTimeout的时候，emit方法将在作为宏任务被放入宏任务队列，将在下一次的事件循环开始时被主线程取出放入执行栈执行，而这时异步更新队列中的销毁SubComponent的操作已经被执行，所以在emit方法被调用的时候，SubComponent已经不存在了。

# 33.在Vue3的setup()函数中获取全局实例方法

> - 在Vue2中，我们可以通过this.$来获取全局实例方法
>
>   - 一个例子
>
>     ```{jsx}
>     this.$requestLogin()
>     ```
>
>     这样就可以获取定义在main.js中的全局实例方法。
>
> - 但是在Vue3中的setup函数中，由于不存在this，所以上面的方法是不行的
>
>   - 下面提供2种方法
>
>     1. 使用getCurrentinstance()
>
>        ```{jsx}
>        const instance = getCurrentInstance()
>        
>        instance.proxy.$requestLogin()
>        ```
>
>     2. 使用root
>
>        ```{jsx}
>        setup(props,ctx)
>        {
>          ctx.root.requestLogin()
>        }
>        ```

# 34.Vue组件的data域

> - Vue组件中响应式数据必须放在函数的return中返回
>
>   - data对应的函数可以使用普通函数也可以使用剪头函数，这2个有轻微的区别（this）
>
>     - 当data对应的函数是普通函数时，this指向Vue实例
>
>       ```{jsx}
>       data: () => {
>         return {
>           ...
>         }
>       }
>       ```
>
>       
>
>     - 当data对应的函数是剪头函数时，this指向window
>                                                                                                        
>       ```{jsx}
>       data() {
>         return{
>           ...
>         }
>       }
>       ```
>
>   - 当我们需要使用this的时候，建议使用普通函数（如利用props对data赋值）
>
>     ```{jsx}
>     props: ['loading'],
>     data() {
>       return {
>         loading: this.laoding,
>       }
>     }
>     ```

# 35.slot属性问题

> - 在Vue3中slot属性来指定访问具名slot的方法已经被移除
>
>   下面给出的内容是父组件模版中的部分。
>
>   ```{jsx}
>   <User slot='name'>
>     ....
>   </User>
>   ```
>
>   这样如果设置了eslint的话容易碰到，vue `slot` attributes are deprecated.，这个报错说明slot属性已经被弃用
>
>   上面的含义是在父组件模版中定义了将子组件\<User>标签下的内容插入到子组件\<User>的name具名插槽。
>
> - 解决方案
>
>   ```{jsx}
>   <User v-slot:name>
>     ...
>   </User>
>   ```

# 36.如何在setup函数中获取router和route

> - 获取router
>
>   - 获取router的2种方法
>
>     1.使用ctx.root.$router来获取
>
>     ```{jsx}
>     setup(props,ctx) {
>     onMounted(() => {
>       console.log(ctx.root.$router)
>     })
>     }
>     ```
>
>   	2.通过useRouter来获取
>
>     ```{jsx}
>   setup(props,ctx) {
>     const router = useRouter()
>     onMo	unted(() => {
>       console.log(router)
>     })
>   }
>     ```
>
>   - 我们可以看到，这2种方法获取的router都是
>
>     ![截屏2022-03-11 上午12.39.19](/Users/bytedance/Desktop/截屏2022-03-11 上午12.39.19.png)
>
> 
>
> - 获取route
>
>   1. 第一种方法我们可以使用从router中获取的方法
>
>      ```{jsx}
>      setup(props,ctx){
>        onMounted(() => {
>          console.log(ctx.root.$router)
>        })
>      }
>      ```
>
>      将router打印出来，我们可以发现，route是包含在router中的
>
>      ![截屏2022-03-11 上午12.39.19](/Users/bytedance/Desktop/截屏2022-03-11 上午12.39.19.png)
>
>   2. 第二种方法，可以使用useRoute来获取
>
>      ```{jsx}
>      setup(props,ctx) {
>        const route = useRoute()
>        onMounted(() => {
>          console.log(route)
>        })
>      }
>      ```
>
>      最终获取的route结果是
>
>      ![截屏2022-03-11 上午12.45.55](/Users/bytedance/Desktop/截屏2022-03-11 上午12.45.55.png)
>

# 37. ::before和::after伪元素失效在某些情况下失效的问题

> - 一个问题
>   - 当我需要为内联引入的svg挂载::before或::after伪元素的时候，伪元素失效了，完全不显示，并且使用开发者工具也找不到。
> - 为什么会在一些情况下，before和after伪元素会失效
>   - W3C的文档给出了失效的原因（https://www.w3.org/TR/CSS21/generate.html#before-after-content）
>     - ​	1·	
>   - 
> - 

# 38.Nuxt.js 的 fetch API

> - 什么时候使用fetch，fetchAPI有什么作用
>
>   - fetch API的作用
>     - fetch API会在每次组件加载前被调用（也就是说fetch会在服务端或切换至目标路由之前被调用）。
>   - 什么时候使用fetch API
>     - 从上面的fetch API的作用，我们可以利用fetch API在服务端获取数据，在服务端获取数据的好处是可以在一些情况下，避免页面加载时闪动。
>     - 但是如果我们是为了在服务端获取数据而使用fetch API，那么需要避免在切换至目标路由的时候调用（可以判断一下，目标待获取数据是否已经获取完毕）。
>
> - fetch API的使用
>
>   
>
> - 

# 39.服务上线前注意工作

> 需求开发完，在合并到master前，先把.ferryrc 文件里的分支改成master（确保服务端已经合并到master后），然后再执行一下 npm run gen-api。保证不要把别的需求的接口给合没了啊

# 40.当上线master之前，如果需要本地rebase

> - 问题情况
>   - 有时候会遇到要合并到master时，需要本地rebase，当我们在本地rebase之后，发现想要push到远程库会失败（因为这时远程库和本地不一致）
> - 解决方案
>   - 这时我们需要先看下远程库有没有别人添加的新提交
>     - 如果没有，那么我们可以直接push -f（覆盖了远程库，所以要看下别人有没有提交）

# 41. npm的一些常用命令

> - npm的作用/什么是npm
>
>   - npm是node package manager，也就是一个包管理工具（由于JS支持模块化，所以很多模块可以复用，也就是包）。
>
> - 安装npm
>
>   - 可以通过安装node.js顺带安装npm，因为npm是node.js的默认包管理工具，所以安装node.js之后，npm也安装好了。
>
>     ```{shell}
>     node -v
>     npm -v
>     ```
>
>     可以使用-v参数来查看node.js和npm的版本，以此检查是否安装完成。
>
> - 使用npm安装指定包
>
>   - 假设要使用npm安装vue
>
>     ```{shell}
>     npm install vue
>     ```
>
>     npm install + 包名，可以安装指定包。
>
>   - 假设需要使用npm安装vue的指定版本
>
>     ```{shell}
>     npm install vue@2.0.0
>     ```
>
>     使用@可以指定安装包的版本。
>
> - package.json文件和package-lock.json文件
>
>   - package.json文件
>
>     - package.json文件的作用是管理本地安装的包。
>     - package.json文件中包含我们项目所依赖的所有包，以及这些包的版本。
>     - package.json文件是通过npm init初始化项目时生成的。
>
>   - packag-lock.json文件
>
>     - package-lock.json的作用是记录项目所依赖的模块的版本，防止在执行npm install重新下载依赖（可以用于更新依赖）时自动升级版本导致错误。
>     - package-lock.json文件会记录每个依赖的详细信息，包括具体版本号、下载url、每个依赖的子依赖的信息。
>
>   - 使用npm install命令更新模块的过程
>
>     - npm install的过程会有以下
>
>       1.从package.json文件中读取所有依赖的信息（名称和版本号）。
>
>       2.与node_modules文件夹中已经安装的依赖对比。
>
>       3.如果缺少依赖，那么就会去读取package-lock.json文件中的下载url，进行下载。
>
>       4.如果已经存在依赖，那么会去package-lock.json文件检查版本号是否一致，如果不一致，也会去对应的下载url下载。
>
> - npm常用参数
>
>   - -save
>
>     ```{shell}
>     npm install vue -save
>     ```
>
>     -save参数表示将包安装为生产环境依赖，并将模块添加到package.json文件的dependencies中（表示这是生产环境依赖。）
>
>   - -save-dev
>
>     ```{shell}
>     npm install vue -save-dev
>     ```
>
>     -save-dev参数表示将包安装为生产环境依赖（构建工具打包的时候不会带上生产环境依赖），并将模块添加到package.json文件的devdependencies中。
>
>   - -g
>
>     ```{shell}
>     npm install typescript -g
>     ```
>
>     -g参数表示全局安装，当全局安装之后，我们就可以在所有目录下使用这个包，当我们可能需要在命令行中使用这个包的时候，我们需要全局安装。

# 42.如何在SCM打包

> - 什么时候需要在SCM打包
>   - 当需要更新版本的时候，如果没有配置流水线，那么需要先去SCM平台打包，才能在字节云发布新版本。
> - 如何在SCM打包之后发布新版本
>   - 一个例子
>     - 对于juejin_admin，由于它没有配置流水线，当我们想要发布到BOE时，需要先在SCM平台找到对应服务，juejin_admin
>     - 第二步是，点击发布版本，然后选择分支以及版本类型（当我们想要发布到BOE，需要选择线下版本），然后点击确定，就开始打包了。
>     - 第三步是，等待SCM打包完成，到字节云对应服务，点击升级，选择刚刚打包好的线下版本包，点击下一步，点击提交。

# 43.node常用语法汇总

> - _\_filename和\_\_dirname
>
>   - __filename是当前模块（任何一个文件都是node中的模块）的绝对路径。
>
>   - __dirname是当前模块的绝对路径。
>
>     ![图像2022-3-23 下午8.47](/Users/bytedance/Downloads/图像2022-3-23 下午8.47.jpg)
>
>     ![图像2022-3-23 下午8.48](/Users/bytedance/Downloads/图像2022-3-23 下午8.48.jpg)
>
> - path.resolve([...paths])
>
>   - path.resolve()接受路径或路径片段组成的序列，path.resolve()方法将路径或路径片段解析为绝对路径。
>
>   - path.resolve()工作逻辑
>
>     - path.resolve()将从右向左处理给定的路径序列，每个后续的path将被追加到前面，直到构建绝对路径。
>
>       ```js
>       path.resolve（'/foo','/bar','baz'） ///bar/baz
>       ```
>
>       在上面的例子中，path.resolve()将从右向左，首先读取了baz，这是一个相对路径，所以继续工作，再读取了/bar放在baz前面构成/bar/baz，这是一个绝对路径，所以停止工作。
>
>     - 如果path.resolve()到最终也没有获取绝对路径，那么将使用__dirname。
>
>   - path.resolve()易错
>
>     - 一个例子
>
>       ![图像2022-3-23 下午9.21](/Users/bytedance/Downloads/图像2022-3-23 下午9.21.jpg)
>
>       ![图像2022-3-23 下午9.22](/Users/bytedance/Downloads/图像2022-3-23 下午9.22.jpg)
>
>       上面的例子中，path.resolve(__dirname,'..','demo.ts')最终输出'Users/demo.ts'
>
>       __dirname是'/Users/jersey'，然后..是‘/Users’，最后path.resolve()读取到..，由于..是相对路径，表示上一级目录，path.resolve()会将..仍视为..，但是会将..后面读取的路径，（在这个例子中是\_\_dirname），去掉一级。
>
>       这里__dirname是有特别用处的，由于每个人电脑上的绝对路径都是不一样，所以使用\_\_dirname来动态获取是可以保证正确的。（如果不加\_\_dirname，由于node在不同路径下运行的时候..是不一样，这样最终获取的路径也会不一样导致出错）。
>
> - process进程
>
>   - process进程提供有关当前Node.js进程的信息并对其进行控制。
>
>   - 使用process的方法
>
>     - process全局可用，但是建议使用import 或 require来显式访问
>
>       ```{js}
>       import process from 'process';
>       const process = require('process');
>       ```
>
>   - process.env
>
>     - process.env属性将返回用户环境的对象。
>
>   - process.cwd()
>
>     - procee.cwd()方法返回Node.js进程的当前工作目录。（这个值会随着Node.js进程的工作位置不同而改变）。
>
>   - 
>
> - 

# 44.Rollup.js常用选项汇总

> - input
>
>   - 用于指定构建的入口点。
>
> - output
>
>   - 接受string或一个对象
>
>     - string
>
>       ​	用于指定要写入的文件。
>
>     - 对象
>
>       ```{typescript}
>       enum outputFormat{
>         amd = 'amd', //异步模块定义，用于RequireJS这样的模块加载器
>         cjs = 'cjs', //CommonJS，适用于Node和Browserify/Webpack
>         esm = 'esm', //将软件包保存为ES模块文件，在现代浏览器中可以使用<script type="module">引入。
>         iife = 'iife', //一个自动执行的功能，适合作为<script>标签。（如果要为应用程序创建一个捆绑包，您可能想要使用它，因为它会使文件大小变小。）
>         umd = 'umd', //通用模块定义，以amd，cjs 和 iife 为一体
>         system = 'system' //SystemJS 加载器格式
>       }
>       
>       
>       interface outputType{
>         format: outputFormat; //用于指定生成包的格式
>         esModule: boolean;
>         entryFileNames: string;
>         chunkFileNames: string;
>         assetFileNames: string;
>         manualChunks: {}
>       }
>       ```
>
>       
>
>     - 
>
> - 

# 45.NVM用法

> - nvm的作用/什么是nvm
>
>   - nvm全名是 node.js version management，用于管理node.js版本，一般我们可以使用nvm来管理node.js的版本，以解决node.js各种版本存在的不兼容问题。
>
> - 为什么需要管理node.js的版本
>
>   - 在实际工作中，我们可能同时进行多个不同项目的开发，由于每个项目的需求不同，进而不同项目需要依赖的node.js版本不同，这时我们就需要在同一台设备上切换不同的node.js版本。
>
> - nvm、node.js、npm的区别
>
>   - nvm用于管理node.js和npm的版本。
>   - npm用于管理node.js的第三方库。
>
> - 安装nvm
>
>   - 命令行安装
>
>     ```{sh}
>     curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.38.0/install.sh | bash
>     ```
>
>     ![截屏2022-03-24 下午2.54.50](/Users/bytedance/Desktop/截屏2022-03-24 下午2.54.50.png)
>
>     图中，框内说明缺少环境，将框中命令复制后在命令行运行。
>
>   - 手动安装
>
>     - https://github.com/nvm-sh/nvm ，下载zip，并解压缩
>
>     - 第二步，找到install.sh文件及路径，并在命令行运行以下命令
>
>       ```{sh}
>       sh install.sh
>       ```
>
>   - 检查nvm是否安装成功
>
>     ```{sh}
>     nvm use system
>     ```
>
>     ![截屏2022-03-24 下午2.58.09](/Users/bytedance/Desktop/截屏2022-03-24 下午2.58.09.png)
>
> - nvm使用方法
>
>   - 安装稳定版node.js
>
>     ```{sh}
>     nvm install stable
>     ```
>
>   - 安装指定版本node.js
>
>     ```{sh}
>     nvm install 10.14.1
>     ```
>
>     上面的命令表示安装10.14.1版本的node.js。
>
>   - 删除指定版本node.js
>
>     ```{sh}
>     nvm uninstall 10.14.1
>     ```
>
>     上面的命令表示删除10.14.1版本的node.js。
>
>   - 切换使用其他版本的node.js
>
>     - 临时切换
>
>       ```{sh}
>       nvm use 10.14.1
>       ```
>
>       上面的命令表示在当前窗口切换为10.14.1版本的node.js。
>
>     - 全局切换
>
>       ```{sh}
>       nvm alias default use 10.14.1
>       ```
>
>       上面的命令表示全局（所有窗口）切换为node.js 10.14.1版本的运行时环境。
>
>     - 切换node.js版本的易错点
>
>       - 在VScode的终端中运行命令切换了node.js版本，必须将VScode关掉（把VScode进程杀掉）重启才可以生效。
>
>   - 列出所有已安装的node.js版本
>
>     ```{sh}
>     nvm ls
>     ```
>
> - macOS安装踩坑点
>
>   - 问题描述
>
>     - 当在macOS安装的时候，有可能遇到安装成功之后，关闭命令行工具，再次打开之后运行nvm提示找不到命令。
>
>   - 解决方法
>
>     首先检查 ~/.zshrc 文件是否存在，如果不存在新建一个
>
>     ```{sh}
>     touch ~/.zshrc
>     ```
>
>     第二步，使用vim编辑器打开 ~/.zshrc 文件，使用插入模式向文件中插入以下命令
>
>     ```{sh}
>     vim ~/.zshrc
>     :i
>     export NVM_DIR="$HOME/.nvm"
>     [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh" # This loads nvm
>     [ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"  # This loads nvm bash_completion
>     :w
>     :q
>     ```
>
>     第三步，再次安装nvm。

# 46.vite配置实践理解汇总

> - build选项
>
>   - build选项的常用属性
>
>     ```{typescript}
>     interface buildType{
>       sourcemap?: boolean | 'inline' | 'hidden';
>       assetsDir?: string
>     }
>     ```
>
> 
>
>   - assetsDir属性（将影响打包后js、png、css等静态资源的存放路径，相对于打包后项目根目录而言，并且对应的引用也将对应更新，和base不同的是，base只影响公共部分）
>
>     - assetsDir属性作用
>       - assetsDir属性影响的是构建后的静态资源（图片等）的存放路径
>     - assetsDir属性有什么影响
>       - 静态属性的存放路径肯定会影响代码中对这些静态资源的引用部分（如，img标签使用src引用图片，import 一个指定路径的svg）。
>       - 构建的时候构建工具会根据assetsDir属性去修改这部分引用的路径。
>
>   - publicDir属性（将影响开发期间的静态资源访问路径）
>
>     - publicDir属性用于指定静态资源的路径，如项目在跑起来之后会引用某个png资源(a.png)。
>
>       - 如果没有配置publicDir属性，那么项目将引用'./a.png'路径的资源。
>
>       - 如果配置publicDir属性为'assets'，那么项目将引用'assets/a.png'路径的资源。
>
>         ![截屏2022-04-01 上午11.51.32](/Users/bytedance/Desktop/截屏2022-04-01 上午11.51.32.png)
>
>         对于这种情况，如果不配置publicDir，那么开发环境中将引用bigger_project中的a.png，如果想要引用vite_project中的a.png，需要将publicDir配置为publicDir: './'。
>
> - base属性（base属性配置只影响生产环境）
>
>   - base属性涉及替换的部分
>
>     - 当设置了base属性，那么JS 引入的资源 URL，CSS 中的 `url()` 引用以及 `.html` 文件中引用的资源在构建过程中都会自动调整。
>
>     - 一个例子
>
>       ```{typescript}
>       export defalut defineConfig({
>         base: '/abc'
>       })
>       ```
>
>       那么对应的，如html中对资源引用的路径会在前面加上/abc
>
>       ```{html}
>       <html>
>         ...
>         <script src="/abc/...."></script>
>       </html>
>       ```
>
>   - 一般是当我们的vite项目不在生产环境网站的根目录下，假设需要将vite项目部署在www.example.com/foo/bar路由下，那么就需要配置base，base: '/foo/bar'
>
> - 

# 47.Linux Shell命令汇总

> - echo
>
>   - echo命令用于字符串输出
>
>     ```{sh}
>     echo string
>     ```
>
>   - 使用示例
>
>     ```{sh}
>     echo "hello aa bb cc"
>     ```
>
>     上面表示将会打印出 hello aa bb cc
>
>     ```{sh}
>     echo hello aa bb cc
>     ```
>
>     不加引号也是可以的，将打印出和上面一样的字符串。
>
>     ```{sh}
>     a='a'
>     echo hello aa bb cc $a
>     ```
>
>     结合变量也可以使用，将打印出hello aa bb cc a。
>
> - 条件语句
>
>   - 单if语句
>
>     ```{sh}
>     if [ 条件判断 ]; then
>     	... //执行语句
>     ```
>
>     ```{sh}
>     if [ pwd = '/User/XXX/Desktop' ]; then
>     	echo 'now is Desktop'
>     ```
>
>   - 多分支
>
>     ```{sh}
>     if [ pwd = '/Users/XXX/Desktop' ]; then
>     	echo 'now is Desktop'
>     else
>     	echo 'not in Desktop'
>     fi
>     ```
>
>   - 
>
> - rm命令（小心使用）
>
>   - rm命令用于删除指定文件/目录
>
>     ```{sh}
>     rm test.txt
>     rm：是否删除 一般文件 "test.txt"? y  
>     ```
>
>     上面的命令表示删除test.txt，由于没有加参数，所以删除前会询问。
>
>     ```{sh}
>     rm -r homework
>     rm：是否删除 目录 "homework"? y 
>     ```
>
>     上面的命令表示删除目录 homework 及其以下的所有档案，如果要删除目录，必须使用参数 -r
>
>   - 常用参数
>
>     1. -i，删除前逐一询问确认
>     2. -f，即使设置属性为只读，也将强制删除，并且无须逐一确认
>     3. -r，将目录及以下的档案逐一删除
>
> - cp命令
>
>   - cp命令（copy file）用于复制文件/目录。
>
>     ```{sh}
>     cp [options] source dest
>     ```
>
>   - 常用参数
>
>     1. -a，在复制目录时使用，保留链接、文件属性，并复制目录下所有内容。
>     2. -d，复制时保留链接，这里的链接相当于Windows系统中的快捷方式。
>     3. -f，覆盖已经存在的目标文件而不给出提示。
>     4. -i，覆盖已经存在的文件，给出提示，要求用户确认
>     5. -r/-R，在复制目录时使用，如果源文件是一个目录文件，此时将复制该目录下所有的子目录和文件。
>
>   - 
>
> - touch命令
>
>   - touch命令用于修改文件的权限或创建一个新文件。
>
> - find命令
>
>   - find命令用于在指定目录下查找文件。
>
>   - 任何在参数之前的字符串都将会被视为查找的目录。
>
>   - 如果没有指定目录，那么默认查找当前目录下的文件。
>
>     ```{sh}
>     find .
>     ```
>
>     列出当前目录及子目录下的所有文件和文件夹。
>
>     ```{sh}
>     find /home -name "*.txt"
>     ```
>
>     在/home目录下查找以.txt结尾的文件名。
>
>   - 常用参数
>
>     - -name，按文件名查找。
>     - -iname，按文件名查找且不区分大小写。
>     - -perm，按文件权限查找文件。
>     - -path \<PATH>，用于指定具体某个目录，find将在这个目录下查找
>
>   - 

# 48.什么是Node、什么是Express

> - 什么是Node
>
>   - Node可以让我们利用JavaScript创建Web服务端应用。
>
> - 使用Node的http库创建一个基础服务端应用
>
>   ```{sh}
>   mkdir test-node
>   ```
>
>   首先在当前目录创建一个文件夹用于存放项目。
>
>   ```{sh}
>   cd test-node
>   touch hello.js
>   ```
>
>   在test-node目录下创建一个hello.js文件
>
>   ```{sh}
>   vim hello.js
>   :i
>   const http = require("http");
>   
>   // 创建 HTTP 服务器并监听 8000 端口的所有请求
>   http.createServer((request, response) => {
>   
>      // 用 HTTP 状态码和内容类型来设定 HTTP 响应头
>      response.writeHead(200, {'Content-Type': 'text/plain'});
>   
>      // 发送响应体 "Hello World"
>      response.end('Hello World\n');
>   }).listen(8000);
>   
>   // 在控制台打印访问服务器的 URL
>   console.log('服务器运行于 http://127.0.0.1:8000/');
>   :w
>   :q
>   ```
>
>   使用vim将上面的内容写入hello.js文件。
>
>   ```{sh}
>   node hello.js
>   ```
>
>   使用node运行hello.js，这时，我们可以打开浏览器访问，http://localhost:8000/
>
> - 什么是Express
>
>   - 由于Node没有适用于常用的服务端应用的开发任务的API，所以有了Express这个基于Node的框架，Express提供了开发服务端应用的常用API。

# 49. 如何在TS项目中使用node默认包

> - 问题背景
>
>   - 我在一个TS项目中需要引入node.js内置的path模块，但是由于node.js不支持TS，所以导致在TS中找不到path包。
>
>     ![rR9msUfn5X](/Users/bytedance/Library/Application Support/LarkShell/sdk_storage/f7c0e3502fc331151b4233e0ad8850a2/resources/images/rR9msUfn5X.jpg)
>
> - 解决方法
>
>   - 使用npm下载开发环境依赖
>
>     ```{sh}
>     npm install @types/node --save-dev
>     ```

# 50.Express常用API

> - Express的作用
>   - Express用于提供一个开发服务器，当发出http请求，Express会返回http response。
> - res
>   - res.send()
>     - 
>   - 
> - 

# 51. Jupiter开发SPA

> - 在开发环境调试
>
>   - 启动服务
>
>     ```{sh}
>     yarn dev
>     ```
>
>   - 页面路由
>
>     - 一个例子
>
>       假设jupiter项目的项目结构是
>
>       src
>
>       ​	pages
>
>       ​		app.tsx
>
>       ​		Front
>
>       ​			About
>
>       ​				index.tsx
>
>     - 那么如果我们想要访问app.tsx的页面，需要进入localhost/app
>
>     - 如果想要进入about页面，那么需要进入路由localhost/front/about
>
>     - 如果路由不对，那么会进入404页面。
>
>   - 
>
> - 项目结构梳理
>
>   - 常用组件
>
>     - 常用组件可以放于src/components目录下。
>
>     - 当需要在src/pages下的页面中import组件的时候，为了保证在不同设备上保持import的路径正确，需要配合配置alias使用。
>
>       ```{javascript}
>       const path = require('path');
>       module.exports = {
>         source: {
>           alias: {
>             '@': path.resolve(__dirname,'src') //__dirname是配置文件的当前目录
>           }
>         }
>       }
>       ```
>
>       上面的例子中，我们将src目录的绝对路径定义了一个别名 @。
>
>   - 
>
> - 项目开发常见问题
>
>   - 内联引入SVG
>
>     ```{tsx}
>     import { ReactComponent as Logo } from './logo.svg';
>     
>     const App = () => {
>       return <Logo />;
>     };
>     ```
>
>     内联引入SVG的方法实际上取决于loader。
>
>   - 在项目中使用图片等静态资源
>
>     ```{tsx}
>     import logoUrl from './logo.png';
>     
>     const App = () => {
>       return <img src={logoUrl} />;
>     };
>     ```
>
>     如果直接使用src=“URL”，那么打包的时候不会对url进行处理，就会导致无法访问到相应静态资源。
>
>   - 
>
> - 

# 52.React.FC

> - TS泛型
>
>   - TS泛型是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的特性。
>
> - React.FC
>
>   - React.FC表示函数式组件，是在TypeScript中使用的一个泛型。
>
> - 为React.FC传入props
>
>   - 一个例子
>
>     ```{tsx}
>     interface PropsType{
>       msg?: string;
>     }
>     const app: React.FC<PropsType> = ({msg}) => { //{msg}相当于解构赋值，从props中解构
>       return(
>         <h1>hello,{msg}</h1>
>       )
>     }
>     ```
>
>     想要使用props，必须为React.FC提供泛型定义。
>
> - 为自定义组件定义className
>
>   - className
>
>     - className相当HTML中的class，由于React书写的是tsx，是类js的语法，所以会受到js语法的约束，所以不能直接使用class关键字，只能使用className关键字定义css类名。
>
>   - 一个例子
>
>     ```{scss}
>     .subClass{
>       ...
>     }
>     .classA{
>       ...
>     }
>     ```
>
>     上面是父组件对应的css module，采用下面的方法，可以使我们可以在父组件的css module中定义子组件的样式。就像操作普通DOM元素一样。（普通DOM元素直接定义className就可以在父组件的css module中定义样式）。
>
>     ```{tsx}
>     import subComponent from '...';
>     import styles from './index.module.scss';
>                                                             
>     const parentComponent: React.FC = () => {
>       return(
>         <>
>         	<subComponent className={styles.subClass} />
>         	<div className={styles.classA}></div>
>         </>
>       )
>     }
>     ```
>
>     上面是父组件中的内容，实际上className将会作为props传给subComponent。而在父组件中使用styles.XXX，相当于将定义在父组件的index.module.scss中的对应样式整个传给子组件。
>
>     这也是为什么在父组件中的index.module.scss中的.subClass类不需要加上:global，而.subClass的子类（对应想要在父组件的样式文件中修改子组件内部的样式）需要加上:global。
>     
>     ```{tsx}
>     const subComponent: React.FC<{className: string}> = ({className}) => {
>       return(
>         <div className={className}>
>           ...
>         </div>
>       )
>     }
>     ```
>     
>     注意为子组件定义className，传入的className应该赋值给根元素的className。

# 53.scss和sass的区别

> - sass
>   - sass的文件扩展名是.sass。
>   - sass在构建工具中需要使用sass-loader打包。
>   - sass的语法是以严格的缩进式语法规则来书写，不带有大括号和分号。
> - scss
>   - scss的文件扩展名是.scss。
>   - scss在构建工具中使用scss-loader。
>   - scss语法包含大括号和分号。
>   - scss是sass 3引入的新语法。

# 54.当需要在HTML中显示多个空格

> - 问题背景
>
>   - 在一段文本中，如果想要显示多个空格，即使在HTML中打了多个空格也是不起作用的，如何解决这种问题。
>
> - 解决方法
>
>   - 使用css word-spacing属性
>
>     - word-spacing属性用于调整空格的宽度，支持单位px、rem、em等。
>
>   - 一个例子
>
>     ```{tsx}
>     const app: React.FC = () => {
>       return (
>         <span style={{wordSpacing: '20px'}}>hello aaa bbb ccc</span>
>       )
>     }
>     ```
>
>     上面的例子中，文本中的空格的宽度是20px。

# 55.利用before伪元素挂载svg

> - 一个例子
>
>   - 当我们需要在某个元素之前或之后挂载svg，我们可以使用before或after伪元素。
>
>     ```{tsx}
>     const app: React.FC = () => {
>       return (
>         <>
>         	<span className='A'>hello</span>
>         </>
>       )
>     }
>     ```
>
>     上面给出了一个span元素，如果我们想要在span元素之前挂载一个svg。
>
>     ```{scss}
>     .A{
>       &::before{
>         content: '';
>         background-image: url('./assets/icon.svg');
>         background-size: 1px 2px;
>         height: 2px;
>         width: 1px;
>         position: absolute;
>         top: ...;
>         display: inline-block;
>       }
>     }
>     ```
>
>     上面是对应的挂载svg的scss
>
>     - background-image，用于指定挂载的svg
>     - background-size，用于设置svg图片的大小。
>     - height，需要与background-size中的height对应（否则会重复图片）
>     - width，需要与background-size中的width对应。
>     - position，用于指定svg的位置。

# 56.video标签

> - video标签的作用
>
>   - video标签的作用是在HTML中挂载视频文件。
>   - video标签是HTML5中的新标签。
>
> - video标签支持的MIME类型
>
>   - MP4、WebM、Ogg。（但是不同浏览器支持不同类型）。
>
> - video标签的常用属性
>
>   - video标签有9个常用属性
>
>     - autoplay
>
>       ```{html}
>       <video autoplay="autoplay"></video>
>       ```
>
>       用于使视频在加载完成后立即播放。
>
>     - controls
>
>       ```{html}
>       <video controls="controls"></video>
>       ```
>
>       当使用了controls属性，则向用户展示播放控件，如播放按钮。
>
>     - height
>
>       ```{html}
>       <video height="20px"></video>
>       ```
>
>       用于指定视频播放器的高度。
>
>     - width
>
>       ```{html}
>       <video width="20px"></video>
>       ```
>
>       用于指定视频播放器的宽度。
>
>     - loop
>
>       ```{html}
>       <video loop="loop"></video>
>       ```
>
>       如果使用loop属性，那么播放完后将重复播放。
>
>     - muted
>
>       ```{html}
>       <video muted="muted"></video>
>       ```
>
>       如果使用muted属性，那么将静音播放。
>
>     - poster
>
>       ```{html}
>       <video poster=URL></video>
>       ```
>
>       用于指定视频在下载时的封面，直到用户点击播放按钮。
>
>     - preload
>
>       ```{html}
>       <video preload="auto"></video>
>       ```
>
>       当使用auto属性值时，视频将在页面加载的时候加载。
>
>     - src
>
>       ```{html}
>       <video preload=URL></video>
>       ```
>
>       用于指定要播放视频的URL。

# 57.React TSX事件处理

> - 问题背景
>
>   - 为元素绑定onClick事件处理函数时，报错 不能将类型“void”分配给类型“MouseEventHandler<HTMLImageElement>”
>
> - 解决方法
>
>   - 使用剪头函数。
>
>     ```{tsx}
>     const app: React.FC = () => {
>       return (
>         <div>
>           <di onClick={() => {...}}></div>
>         </div>
>       )
>     }
>     ```

# 58. React函数式组件使用ref

> - ref
>
>   - ref的作用
>     - ref用于获取DOM元素或子组件实例。
>
> - useRef
>
>   - useRef作用
>
>     - useRef用于返回一个可变的ref对象。这个refduix的current属性被初始化为useRef传入的参数initialValue。
>     - useRef返回的ref对象在整个生命周期中保持不变。（意思是这个ref对象的地址一直不会变）。
>     - ref对象变化不会触发视图更新。（但是当有state改变时，ref对象的变化也会显示在视图上）。
>     - 获取的DOM实例将会储存在current属性。（current属性指向DOM实例）
>
>   - useRef使用
>
>     - 在普通DOM元素上使用
>
>       ```{tsx}
>       const app: React.FC = () => {
>         const element = useRef(null);
>         return (
>           <>
>           	<input ref={element}></input>
>           	<button onClick={() => {element.current.focus()}}>click</button>
>           </>
>         )
>       }
>       ```
>
>       在上面的例子中，我们先使用useRef创建了一个ref对象，并且将这个ref对象的current属性初始化为null，再将elemnet这个ref对象赋给普通DOM元素的ref属性。
>
>     - 在组件上使用
>
>       ```{tsx}
>       import { MutableRefObject } from 'react';
>       const parent: React.FC = () => {
>         const childRef: MutableRefObject<any> = useRef(null);
>         return (
>           <>
>           	<Child ref={childRef}>
>           </>
>         )
>       }
>       ```
>       
>       这样还是拿不到子组件的实例，还需要使用forwadRef。
>       
>       forwordRef用在子组件中。（这里的forward是转发的意思，也就是将子组件中想要的DOM元素转发给父组件中使用）。
>       
>       ```{tsx}
>       import { Ref } from 'react';
>       interface PropsType{
>         ref: any; //需要将ref声明为props才可以在父组件的jsx中将ref挂载为子组件的属性。
>       }
>       const Child: React.FC = forwardRef((props,ref: Ref<any>) => {
>         return (
>           <div>
>           	<input type="text" ref={ref}/>
>           </div>
>         )
>       })
>       ```
>       
>       上面的例子中使用forwardRef将Child函数式组件包起来，并将传入的第二个参数ref挂在想要获取的元素上。
>       
>       （实际上在子组件中使用ref是为了获取子组件TSX中的某个DOM元素，直接挂在想要通过ref获取的DOM上）
>       
>       这里需要注意，有可能会出现类型错误，用Ref\<any>声明一下就可以。
>   
> - useImperativeHandle
>
>   - useImpreativeHandle的作用
>
>     - useImpreativeHandle允许我们在子组件使用ref时自定义暴露给父组件的实例值。（减少暴露给父组件的属性，直接使用forwardRef将会暴露整个DOM元素给父组件，而useImpreativeHandle结合forwardRef使用使我们可以指定暴露给父组件的属性）。
>     - useImpreativeHandle应当和forwardRef一起使用。
>     - 因为forwardRef只能从子组件转发一个DOM元素的Ref到父组件，当我们需要从子组件获取两个DOM元素时，就需要使用useImpreativeHandle。
>
>   - useImperativeHandle的用法
>
>     - useImperativeHandle将返回一个Ref对象给父组件，这个对象将被储存在父组件的ref 的current中，通过ref.current可以访问useImperativeHandle返回对象中规定可以访问的方法、属性。
>
>       ```{tsx}
>       import { useRef, useImperativeHandle, Ref, forwardRef } from 'react';
>       interface PropsType{
>         ref: Ref<any>;
>       }
>                                       
>       const sub: React.FC<PropsType> = forwardRef(({},ref) => {
>         const elRef = useRef(null);
>         useImperativeHandle(ref,() => ({
>           focus: () => {
>             elRef.current.focus();
>           },
>           display: elRef.current.style.dispaly,
>           value: elRef.current.value,
>         }))
>         return (
>           <div>
>             <input ref={elRef}></input>
>           </div>
>         )
>       })
>       ```
>
>       useImperativeHandle接受2个参数
>
>       1. 第一个参数是，父组件传递的ref属性。
>       2. 第二个参数是，返回给父组件的对象，将储存在父组件的ref.current。
>
>       ```{tsx}
>       const parentComponent: React.FC = () => {
>         const subRef = useRef(null);
>         return (
>           <>
>             <button onClick={() => {subRef.current.focus()}}></button>
>             <Sub ref={subRef} />
>           </>
>         )
>       }
>       ```
>
>       父组件调用了useImperativeHandle传递过来的对象中的focus()方法。
>
>   - 
>
> - 

# 59.React中修改arco-design组件内部样式（类似于Vue深度选择器）

> - React样式隔离
>
>   - React样式隔离的方式是CSS Module。
>
> - React中类似于Vue中深度选择器的方法
>
>   - Vue中的深度选择器可以在父组件的css中修改子组件中元素的样式。一般常用的是用于修改类似于arco-design的组件库中组件的内部元素的样式。
>
>   - React中类似的方法
>
>     ```{scss}
>     .a{
>       :global{
>         .b{
>           ...
>         }
>       }
>     }
>     ```
>
>     上面是父组件的样式文件。
>
>     .b是子组件中的元素，将.b放在 :global中，就可以修改子组件中.b元素的样式。

# 60. scss中的兄弟选择器

> - 问题背景
>
>   - 当想要hover到元素A的时候，修改元素的display状态。
>
>   - 一开始使用了下面代码
>
>     ```{scss}
>     .elementA{
>       &:hover{
>         .elementB{
>           display: block;
>         }
>       }
>     }
>     ```
>
>     但实际上，上面的scss代码将会编译为
>
>     ```{css}
>     .elementA:hover .elementB, .elementB:hover .elementB{
>       display: block;
>     }
>     ```
>
>     由于在scss中，换行符将会被编译为后代选择器。
>
>     所以我们可以看到，当元素B不是元素A的子元素时，上面的scss是不会起作用的。
>
> - 解决方法
>
>   - 使用兄弟选择器
>
>     ```{scss}
>     .elementA{
>       &:hover + .elementB{
>         display: block;
>       }
>     }
>     ```
>
>     上面的scss将被编译为
>
>     ```{css}
>     .elementA:hover + .elementB, .elementB:hover + .elementB{
>       display: block;
>     }
>     ```
>
> - scss常见编译规则总结（scss在线编辑器 https://www.sassmeister.com/）
>
>   - 换行符
>     - 编译为后代选择器。
>   - &
>     - 编译为父级元素。
>   - +
>     - 编译为兄弟选择器。
>   - 
>
> - 

# 61.引用自定义字体样式

> - 目录结构
>
>   - 将字体文件放在 src/assets/fonts 文件夹中。
>
>     Project
>
>     ​	src
>
>     ​		assets
>
>     ​			fonts
>
>     ​				XXX.ttf
>
>   - 定义一个fonts.scss文件在src/style文件夹中。这个fonts.scss文件用于使用字体文件定义自定义字体。
>
>     Project
>
>     ​	src
>
>     ​		assets
>
>     ​			fonts
>
>     ​				XXX.ttf
>
>     ​		style
>
>     ​			fonts.scss
>
> - 利用字体文件定义自定义字体的方法
>
>   - 使用@font-face
>
>     ```{scss}
>     @font-face{
>       font-family: 'XXX';
>       src: url('...');
>     }
>     ```
>
>     上面的就是文件fonts.scss中的内容。
>
>     font-family，用于定义自定义字体的名称。
>
>     src，用于指定对应的字体文件路径，推荐使用绝对路径，可以使用打包工具配置文件中定义的alias来适配不同设备绝对路径的问题。
>
> - 使用自定义字体的方法
>
>   - 在需要使用自定义字体的scss文件中，import fonts.scss文件。
>
>     ```{scss}
>     @import '@/style/fonts.scss';
>     .a{
>       font-family: 'XXX';
>     }
>     ```
>
> - 检查是否浏览器中加载字体文件的方法
>
>   1. 首先可以选取到使用了自定义字体的元素
>
>   2. 打开这个元素的样式，查看是否是使用的自定义字体。
>
>      ![截屏2022-04-08 下午11.37.10](/Users/bytedance/Desktop/截屏2022-04-08 下午11.37.10.png)
>
>   3. 可以取消勾选这个font-family属性，看字体是否变化。
>
>   4. 可以查看计算样式。
>
>      ![截屏2022-04-08 下午11.34.59](/Users/bytedance/Desktop/截屏2022-04-08 下午11.34.59.png)
>
>   5. 可以查看网络请求中是否有这个字体资源（可以筛选字体，方便查看是否加载字体资源）
>
>      ![截屏2022-04-08 下午11.38.24](/Users/bytedance/Desktop/截屏2022-04-08 下午11.38.24.png)
>
> - 常见误解
>
>   - 彩色的特效字体，实际上不能只靠字体文件实现，还使用了css来实现彩色。（字体文件只能影响字体，而不能影响颜色）。

# 62. React组件定义多个className的方法

> - 问题背景
>
>   - 有时需要对一个jsx中的元素定义多个类名，但是因为jsx不允许重复的属性，所以不能直接使用多个className。
>
> - 解决方法
>
>   - 使用字符串拼接
>
>     ```{tsx}
>     import styles from './index.module.scss';
>     interface PropsType{
>       className: string;
>     }
>     const app: React.FC<PropsType> = () => {
>       return (
>         <>
>         <div className = {styles.link + " " + className}></div>
>         </>
>       )
>     }
>     ```
>
>     
>
>   - 使用模版字符串
>
>     ```{tsx}
>     import styles from './index.module.scss';
>     interface PropsType{
>       className: string;
>     }
>     const app: React.FC<PropsType> = () => {
>       return (
>         <>
>         <div className = {`${styles.link} ${className}`}></div>
>         </>
>       )
>     }
>     ```

# 63.React中点击滚动功能实现

> - 问题背景
>
>   - 当我们在React中需要实现点击某处实现滚动到页面上某位置A的功能。
>
> - 解决方法
>
>   - 使用ref + getBoundingClientRect() + scrollTo
>
>     - 使用ref获取A位置处的DOM元素实例。
>     - 使用getBoundingClientRect()获取滚动到这个DOM实例的距离。（rect.bottom是DOM实例A距离viewport左上角的Y轴上的距离）。
>     - 使用scrollTo({top: dis, behavior: "smooth"})完成滚动。
>
>   - 使用a标签锚点
>
>     ```{tsx}
>     const Sub: React.FC = () => {
>       return (
>         <>
>         	<a href="#aaa"></a>
>         </>
>       )
>     }
>     ```
>
>     当点击a标签的时候，页面会instant滚动到id为aaa的元素处。并且URL后面会加上锚点，www.example.com/extension#aaa
>
>     ```{tsx}
>     const someComponent: React.FC = () => {
>       return (
>         <>
>         	<div id="aaa"></div>
>         </>
>       )
>     }
>     ```
>
>     即使a标签和具有对应id的DOM元素不在一个组件中也没有问题，因为不管在哪个组件中，最终这个页面中都只有一个具有对应id的DOM元素。
>     
>   - 设置平滑滚动
>
>     - 使用CSS属性scroll-behavior
>
>       ```{scss}
>       :global{
>         html{
>           scroll-behavior: smooth;
>         }
>       }
>       ```

# 64.判断一个DOM元素是否在viewport

> - 问题背景
>
>   - 有时候我们需要判断一个元素A是否在viewport中，以进行某种操作。
>
> - 解决方法
>
>   - 使用HTMLElement.getBoundingClientRect()
>
>     - 判断元素A进入viewport的条件
>
>       ```{ts}
>                                                                                                 
>       ```
>
>       
>
>     - 
>
>   - 
>
> - 

# 65.给fetch方法添加timeout的方法

> - 问题背景
>
>   - 在某些时候我们需要对基于fetch的AJAX方法添加timeout，但是不同于XMLHttpRequest，fecth不支持设置timeout。
>
> - 解决方法
>
>   - Promise.race([...])
>
>     - Promise.race()接受以数组形式传入的多个Promise对象，等待第一个resolved或rejected的Promise对象作为自己的状态。
>
>   - 使用Promise.race([...])为fetch添加一个定时resolved的Promise对象
>
>     ```{ts}
>     const timeout = function(){
>       return new Promise((resolve,reject) => {
>         setTimeout(() => {
>           resolve('timeout')
>         },3000);
>       })
>     }
>                                                             
>     const fetchFn = async function(){
>      	const url = "...";
>       const requestBody = {
>         method: 'GET'
>       }
>       await fetch(url,requestBody);
>     }
>                                                             
>     function timeoutFecth = async function(){
>       try{
>         const res = Promise.race([timeout(),fetchFn()])
>         if(res === 'timeout')
>           {
>             console.log('timeout');
>           }
>       }catch(err){
>         console.warn('error',err);
>       }
>     }
>     ```

# 64.React中实现类似v-click-outside效果

> - 问题背景
>
>   - 有时候我们需要点击某个下拉框等元素、组件的外部关闭下拉框。
>
> - 解决方法
>
>   - 使用window.addEventListener监听整个页面
>
>     ```{ts}
>     const [elVisible,setElVisible] = useState(false)
>     const handle = (event) => {
>       if(!el.current?.contains(event.target) && elVisible)
>         {
>           setElVisible(false)
>         }
>     };
>     window.addEventListener('click',handle)
>     ```
>
>     在上面的handle函数中，我们判断了点击事件的原始目标是否是el元素或el元素的子元素。
>
>   - 使用useEffect模拟componentDidMounted和componentBeforeUnmount
>
>     ```{ts}
>     useEffect(() => {
>       const [elVisible,setElVisible] = useState(false)
>     	const handle = (event) => {
>         if(!el.current?.contains(event.target) && elVisible)
>           {
>             setElVisible(false)
>           }
>     	};
>     	window.addEventListener('click',handle)
>       return () => window.removeListener('click',handle)
>     })
>     ```
>
>     借助useEffect的副作用函数将在组件挂载之后执行的性质模拟componentDidMounted，并且副作用函数的return将在组件销毁前执行，这样我们可以用于销毁监听器，避免内存泄漏。
>

# 65.基于Jupiter项目配置TEA

> 1. 运行yarn new，启用TEA。
> 2. 配置Jupiter.config.js，可以参照代码编辑器
> 3. 使用npm安装@byted-juejin/tea-utils，对应版本号是1.5
> 4. initTEA
> 5. 上报TEA

# 66.当有popup的时候，禁止页面滚动方案

> - 问题背景
>
>   - 有时候我们需要做一个弹窗，当弹窗出现的时候，我们有可能想要禁止整个页面滚动。
>
> - 解决方案
>
>   - 使用css
>
>     - 我们知道页面的滚动是由于页面内容超出viewport，且overflow属性被设置为auto或scroll。
>
>       ```{tsx}
>       useEffect(() => {
>         const handle = () => {
>           if(isLockScroll)
>           {
>             document.body,style.overflow = 'hidden';
>           }
>           else{
>             document.body.style.overflow = '';
>           }
>         }
>       },[isLockScroll])
>       ```

# 67.Vue \<router-view>用法

> - \<router-view>有什么作用
>
>   - \<router-view>一般用于路由管理。当我们需要对页面进行局部刷新的时候，就可以使用\<router-view>。
>
> - \<router-view>具体使用场景
>
>   - 例如，我们创建了一个侧边导航栏，并且需要使用侧边导航栏对主页面内容进行切换，主页面切换的时候保持侧边导航栏不变。（类似于掘金签到页面）。
>
> - \<router-view>使用方法
>
>   - 主要是需要对router.js进行配置。
>
>     ```{js}
>     {
>       	path: '/router/view',
>       	name: 'router:view',
>         redirect: '/aPage', //页面将默认加载/aPage路由对应的组件
>         children: [
>           {
>             path: '/aPage',
>             name: 'aPage',
>             component: () => import('@/components/aPage.vue')
>           },
>           {
>             path: 'bPage',
>             name: 'bPage',
>             component: () => import('@/components/bPage.vue')
>           }
>         ]
>     }
>     ```
>
>     上面是路由配置文件。
>
>     /router/view是父路由path。
>
>     children数组中是在父页面中进行切换的子路由path。当在父页面组件中使用this.$router.push({path: '/bPage'})，就会切换成bPage页面。
>
>   - 父页面组件
>
>     ```{vue}
>     <template>
>       <router-view></router-view>
>       <SideMenu @clickA = 'handleClickA' @clickB = 'hanldeClickB' />
>     </template>
>                                                     
>     <script>
>       import SideMenu from '@/componnets/SideMenu';
>       export defineComponents({
>         components: {
>           SideMenu
>         },
>         method: {
>           handleClickA(){
>             this.$router.push({path: '/aPage'})
>           },
>           handleClickB(){
>             this.$router.push({path: '/bPage'})
>           }
>         }
>       })
>     </script>
>     ```

# 68.CSS赋予同一图片不同颜色

> - 问题背景
>
>   - 有时候针对一张图片，我们可能需要这张图片的不同颜色的效果，其中一个显然的解决方案是，分别导出该图片的不同颜色，但显然这种方法需要多储存很多张相同的图片（只有颜色不同）。
>
> - 解决方案
>
>   - 想要将图片颜色保持为其背景颜色
>
>     - 使用mix-blend-mode
>
>       - mix-blend-mode描述了元素的内容应该与元素的父元素内容如何混合。
>
>         ```{css}
>           mix-blend-mode: normal;         // 正常
>           mix-blend-mode: multiply;       // 正片叠底
>           mix-blend-mode: screen;         // 滤色
>           mix-blend-mode: overlay;        // 叠加
>           mix-blend-mode: darken;         // 变暗
>           mix-blend-mode: lighten;        // 变亮
>           mix-blend-mode: color-dodge;    // 颜色减淡
>           mix-blend-mode: color-burn;     // 颜色加深
>           mix-blend-mode: hard-light;     // 强光
>           mix-blend-mode: soft-light;     // 柔光
>           mix-blend-mode: difference;     // 差值
>           mix-blend-mode: exclusion;      // 排除
>           mix-blend-mode: hue;            // 色相
>           mix-blend-mode: saturation;     // 饱和度
>           mix-blend-mode: color;          // 颜色
>           mix-blend-mode: luminosity;     // 亮度
>                                                                                                           
>           mix-blend-mode: initial;
>           mix-blend-mode: inherit;
>           mix-blend-mode: unset;
>         ```

# 69.主站动态绑定图片

> - 问题背景
> - 解决方案
>   - import a from '../assets/a.png'

# 70.scss @content用法

> - @content的作用
>
>   - @content是用在mixin中，当定义了一个含有@content的mixin，那么在使用@include的时候可以使用{}传入内容到mixin。
>
> - 一个例子
>
>   - 给定一个含有@content的mixin
>
>   ```{scss}
>   @mixin colors($color: blue){
>     body{
>       background-color: $color;
>     	@content
>     }
>   }
>   ```
>
>   ```{scss}
>   @include colors{
>     color: white
>   }
>   ```
>
>   最后编译出来的结果是
>
>   ```{scss}
>   body{
>     background-color: blue;
>     color: white;
>   }
>   ```

# 71.scss 插值语句#{}的用法

> - scss插值语句的作用
>
>   - scss插值语句用于字符串中使用scss变量。 
>
> - 一个例子
>
>   - 插值语句一般用于和属性选择器一起用
>
>     ```{scss}
>     @mixin color($name)(
>       .color[data='#{$name}']{
>         @content;
>       }
>     )
>     ```
>
>     .color[data='#{$name}']表示匹配.color类元素中属性data是$name的元素。

# 72.css var()用法

> - var()的作用
>
>   - var()用于插入自定义的属性值，当一个css属性在多个地方使用时，就可以使用var在多个地方引用。
>
> - 使用方法
>
>   - 语法
>
>     ```{css}
>     var(custom-property-name,value)
>     ```
>
>     custom-property-name，必须值，需要以--开头。
>
>     value，可选，在属性不存在时使用。
>
>   - 一个例子
>
>     ```{css}
>     :root{
>       --main-background-color: blue;
>     }
>     .color{
>       background-color: var(--main-background-color,black);
>     }
>     ```
>
>     :root是一个伪类，一般匹配的是html元素。
>
>     所以一般将会多次使用的属性值注入html或body，就可以使用var在页面中多次引用这个属性值了。

# 73. Vue2和Vue3中获取元素

> - Vue2中获取元素
>
>   - 一个例子
>
>     ```{jsx}
>     <template>
>       <div ref="myRef"></div>
>     </template>
>                       
>     <script>
>       export default{
>         mounted(){
>           console.log(this.$refs.myRef)
>         }
>       }
>     </script>
>     ```
>
>     ref只有在mounted之后才能获取到。
>
> - Vue3中获取元素
>
>   - 一个例子
>
>     ```{jsx}
>     <template>
>       <div ref="myRef"></div>
>     </template>
>                                         
>     <script>
>     export defineComponent({
>         setup(){
>           const myRef = ref<HTMLDivElement>()
>           onMounted(() => {
>             console.log(myRef.value)
>           })
>           return{
>             myRef,
>           }
>         }
>       })
>     </script>
>     ```
>
>     ref既可用于声明响应式数据，也可以用于获取元素。

# 74.DOM元素offsetXXX的理解

> - offsetXXX的作用
>   - 当需要将子元素A滚动到父元素容器的最XXX（top）位置时，滚动距离可以使用offsetXXX（offsetTop）
> - 以offsetTop为例介绍
>   - offsetParent
>     - offsetParent属性指向元素的偏移容器。
>     - 元素的偏移容器是距离该子元素最近的且进行过定位（position非static）的祖先元素，如果都不存在定位，那么指向body元素。
>   - offsetTop
>     - offsetTop返回元素到offsetParent顶部的距离。
>   - 注意点
>     - 只有元素渲染完成才会计入offsetTop。

# 75.v-model

> - 双向绑定
>
>   - 双向绑定的数据一更新，视图就会更新。
>   - 如果视图更新，那么双向绑定的数据也会更新。
>
> - v-model
>
>   - 基础用法
>
>     - v-model可以用于在表单元素上实现双向绑定。
>
>   - 实质
>
>     - v-model本质上是一个语法糖。
>
>       ```{jsx}
>       <input type="text" v-model="smoething" />
>       ```
>
>       等同于
>
>       ```{jsx}
>       <input type="text" :value="something" @input="something=$event.target.value">
>       ```
>
>       v-model相当于自带一个@input，将处理input事件，并将动态绑定为value的变量的值更改为input事件传递的值。
>
>   - v-model的限制
>
>     - v-model只能用于以下4种情况
>       1. \<input>
>       2. \<select>
>       3. \<textarea>
>       4. 自定义components
>
> - 在自定义组件中使用v-model
>
>   - 一个例子
>
>     - 子组件
>
>       ```{jsx}
>       <template>
>         <input type="button" value="cancel" @click="handleClick" />
>       </template>
>       
>       <script>
>         expor defineComponents({
>           emits: ['input'],
>           setup(){
>             const handleClick = () => {
>               emit('input',false)
>             }
>             return {
>               handleClick,
>             }
>           }
>         })
>       </script>
>       ```
>
>       子组件中定义了一个自定义事件input
>
>     - 父组件
>
>       ```{jsx}
>       <template>
>         <ChildComponent v-model="isShow" />
>         <input type="button" value="show" @click="handleClick">
>       </template>
>                                                             
>       <script lang="ts">
>         export defineComponents({
>           components: {},
>           setup(){
>             const isShow = ref<boolean>(false)
>             const handleClick = () => {
>               isShow.value = true
>             }
>             watch(() => isShow.value,(newVal: boolean) => {
>               console.log('isShow',newVal)
>             })
>             return{
>               isShow,
>               handleClick,
>             }
>           }
>         })
>       </script>
>       ```
>
>       在父组件中使用了子组件\<ChildComponent>，并且子组件使用v-model绑定了isShow变量。
>
>       并且父组件中使用了watch监听isShow的值，当isShow的值发生变化的时候，就会打印出来。
>
>       当点击show按钮时，将打印出 isShow true
>
>       当点击cancel按钮时，将打印出isShow false
>
>       说明v-model将会接收子组件中的input事件，并将传递的参数赋值给v-model绑定的变量。

# 76.js获取元素宽度\高度

> - 盒子模型
>
> ![截屏2022-06-28 上午11.26.35](/Users/bytedance/Library/Application Support/typora-user-images/截屏2022-06-28 上午11.26.35.png)
>
> - clientWidth\clientHeight
>   1. clientWidth可以获取元素conent的宽度+左右padding。
>   2. clientHeight可以获取元素content的高度+上下padding。
> - offsetWidth\offsetHeight
>   1. offsetWidth可以获取元素content的宽度+左右padding+左右border。
>   2. offsetHeight可以获取元素content的高度+上下padding+上下border。

# 77.滚动相关API

> - 3个滚动API
>
>   1. Element.scroll({top?: number, left?: number, behaviour?: 'smooth' | 'instant' | 'auto'})
>   2. Element.scrollTo({top?: number, left?: number, behaviour?: 'smooth' | 'instant' | 'auto'})
>   3. Element.scrollBy({top?: number, left?: number, behaviour?: 'smooth' | 'instant' | 'auto'})
>
> - 参数解释
>
>   - top和left是可选的，接受一个number类型的数字，并且它的单位是px。
>   - behaviour: 'smooth' | 'instant' | 'auto'。behaviour属性用于指定如何滑动，'smooth'表示平滑滚动，'instant'和'auto'表示瞬间滚动。
>
> - 相关区别
>
>   1. Element.scroll({left: 200})表示滚动条滚动到y轴200px处。（Element.scrollTo()和Element.scroll表现一致）。
>
>      Element.scroll()多次调用只有第一次会生效，因为它实际上是滚动到指定的坐标点处。
>
>   2. Element.scrollBy({left: 200})表示滚动条在y轴方向上滚动200px。
>
>      Element.scrollBy()多次调用均会生效，因为它实际上是基于当前坐标点继续向指定方向滚动指定距离。
>
> - 使用场景
>
>   1. Element.scroll()和Element.scrollTo()由于是滚动到指定坐标处，因此适合滚动到页面上某一个固定点的场景。
>   2. Element.scrollBy()由于是向在当前坐标点的基础上指定方向滚动指定距离，因此适合向下一页滚动的场景（如，一个权益列表被分成了多个页，每个页之间通过滚动切换）。

# 78.Vue3 Hooks

> - 应用场景
>
>   - 一些独立的逻辑可以抽出来作为一个单独的函数，可以把这个函数称为hooks。
>
> - 理解
>
>   - Hooks和普通的JS函数一样，接收传入参数，输出return。
>   - Hooks有自己的作用域，只有return出来的变量才可以被使用。
>
> - 应用
>
>   - 一个例子
>
>     ```{ts}
>     export const useMyHooks = (data: Ref<number>): {a: number,b: Array<number>} => {
>       ...
>       return {
>         a,
>         b,
>       }
>     }
>     ```
>
>     上面给出了一个Hooks，这个Hooks函数和其他普通函数没有什么区别。我们可以使用export把这个Hooks导出，在其他Vue文件中使用。  
>
>     ```{vue}
>     import { useMyHooks } from './hooks';
>     export defineComponents({
>     	setup(){
>     		return(
>     			...useMyHooks()
>     		)
>     	}
>     })
>     ```
>
>     在执行到setup的return时，会先执行useMyHooks()，然后这个Hooks会return一个对象，因此使用...展开操作符将这个对象展开，这样相当于
>
>     ```{vue}
>     import { useMyHooks } from './hooks';
>     export defineComponents({
>     	setup(){
>     		return(
>     			a,
>     			b,
>     		)
>     	}
>     })
>     ```

# 79.Vue深度选择器坑

> - 问题背景
>   - 有时候遇到手动挂载的组件，它并不会带上data-xxxxx这样的属性。
>   - 写样式时注意小心手动挂载的组件，它们需要全局样式，也就是不是scoped的样式。
> - 解决方案
>   - 使用全局样式，并且小心的为它创建一个独特的样式名，避免影响其他样式。
>   - 不加/deep/

# 80. nextTick的应用场景

- nextTick的作用
  - 在某些操作下在响应式数据改变后，需要对DOM或基于DOM进行操作，这个时候就需要把操作逻辑放入nextTick，否则就不会有反应。
- 实际场景
  - 在成长权益列表的滚动中，有一个问题是当用户从低等级向高等级切换的过程中，如果此时我已经在最大页，那么新加的权益是不会显示出来的。进行的修改操作是每次这种情况都让列表容器自动向右滚动一段距离，这个滚动的距离实际上是根据DOM进行计算的，所以必须等到虚拟DOM渲染到浏览器上才可以，所以必须使用nextTick。

# 81. :nth-child(n)选择器和:nth-of-type(n)选择器

- :nth-child(n)选择器 https://www.w3school.com.cn/tiy/t.asp?f=eg_css_sel_firstchild_3

  - 使用方法

    - X:nth-child(n)表示选中是某个元素的第一个子元素且子元素为X类型（根元素不算作父元素，也就是根元素下的第n个X类型的不会被选中）

      ```{html}
      <style>
      li:first-child
      {
      background:yellow;
      }
      </style>
      </head>
      <body>
      <ul>
        <div>
          <li>aaa</li> <!--被选中 -->
        </div>
        <div>
          <div></div>
          <li>aaa</li><!--不被选中 -->
      	</div>
        <li>咖啡</li> <!--被选中 -->
        <li>茶</li>
        <li>可口可乐</li>
      </ul>
      <ol>
        <li>咖啡</li> <!--被选中 -->
        <li>茶</li>
        <li>可口可乐</li>
      </ol>
      
        <li>咖啡</li>
        <li>茶</li>
        <li>可口可乐</li>
      
      </body>
      </html>
      
      ```

      小心X:nth-child(n)只有在某个父元素下的第n个子元素是X类型才会被选中。

      也可以指定是哪个父元素下的，结合子代或后代选择器

      ul X:nth-child(n)表示选中ul元素下的第一个子元素且子元素的类型是X。

- :nth-of-type(n) https://www.w3school.com.cn/tiy/t.asp?f=eg_css_sel_nth-of-type

  - X:nth-of-type(n)表示选中某个元素下的第n个X类型的元素。
  - 也可以结合父代或子代选择器规定是哪个父元素，div p:nth-of-type(2)表示选中div元素下的子元素中的第2个p类型的元素。

# 82. Vue样式隔离

- 样式隔离的作用

  - 样式隔离可以使组件内的样式只作用于组件内部，不影响外部（这是因为经过打包之后所有文件都被合并成一个大文件，不进行样式隔离处理的样式会变成全局样式）。

- Vue样式隔离的手段

  - 在style标签上加scoped属性。

- Vue样式隔离的原理

  - 属性选择器

    - 实际上上加了scoped的style标签下的所有样式在编译之后都会加上一个属性选择器。

      ```{css}
      .classA[data-xxxx] {
        //样式属性
      }
      ```

      这样我们就不只是选择页面中的classA类的元素了，还需要满足具有data-xxx属性的元素才会被选中。

      相应的DOM上也会加上data-xxx这个属性

      ```{html}
      <div class="classA" data-xxx></div>
      ```

- Vue样式隔离的坑

  - 一个例子

    ```{vue}
    <template>
      <div></div>
      <SubComponent></SubComponent>
    </template>
    ```

    上面给出了一个组件的模板，在这个组件的模板中使用了另一个子组件，假设在父组件和子组件中都使用了样式隔离，经过编译之后父组件中的DOM元素都加上了属性data-aaa，而子组件中的DOM都加上了属性data-bbb

    但是因为子组件的根元素（不含template），也存在于父组件中，因此会同样编译上父组件的属性data-aaa

    在编译之后子组件的DOM结构应该是这样

    ```{html}
    <div data-bbb data-aaa>
      <div data-bbb></div>
      <div data-bbb></div>
      ...
    </div>
    ```

# 83. 获取viewport的宽度和高度

- 获取viewport宽度和高度的作用

  - 可以结合element.getBoundingClient()判断一个元素是否进入可视区域。

- 获取viewport的宽度

  ```{js}
  Math.max(window.innerWidth,document.documentElement.clientWidth);
  ```

  window.innerWidth将包含浏览器窗口的宽度（包含滚动条）。

  document.documentElement将获取根元素（html元素）。

  element.clientWidth将获取包含元素content、padding的宽度（不含滚动条）。

  取较大值的原因是，滚动条不一定存在，只有在可以滚动的时候才存在。

- 获取viewport的高度

  ```{js}
  Math.max(window.innerHeight,document.documentElement.clientHeight);
  ```

  原因和上面相同，innerHeight包含横向滚动条的高度。clientHeight不含横向滚动条的高度。

# 84. 函数的原型链

- 函数的prototype
  - 每个函数在创建的时候都会自动创建一个相对应的原型对象，这个原型对象将被函数的prototype属性引用。
- 函数的\__proto__
  - 函数作为引用类型，它也有它的构造函数（即使不是通过构造函数创建的函数），因此每一个函数作为Function构造函数的实例，它也具有\_\_proto\_\_属性，这个\__proto__将指向Function构造函数的原型对象。
  - 实际上所有引用类型都具有\__proto__。
  - 函数唯一不同的是，它不仅具有\__proto__，还具有prototype。
- 所有引用类型的原型对象的原型对象
  - 所有引用类型的原型对象的原型对象都是Object.prototype，这也是所有原型链的终点。
