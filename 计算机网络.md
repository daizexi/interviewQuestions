# 1.TCP三次握手四次挥手的过程

- 握手的目的

  > TCP是面向连接的协议，握手的目的是检查对方可以进行通信。

- 三次握手

   > TCP会在通信之前，利用TCP首部发送一个SYN包请求建立连接，服务器端收到SYN包之后，会发送SYN\ACK包给客户端，客户端收到之后，会发送ACK包给服务器端。

**三次握手比四次挥手少一次通信的原因，服务端在收到客户端SYN包之后，会发送ACK包给客户端，并发送SYN包，三次握手把服务器发送的SYN和ACK一起发送了。**

- 四次挥手
  
  > 客户端会发送FIN包给服务器端请求断开连接，服务器端会返回ACK包给客户端，但这时服务器端可能还有工作没有处理完，所以需要等待一会，再发送FIN包给客户端，客户端收到之后会发送ACK包给服务器端。

**从这个过程可以看到，TCP发送包的过程中，接收端必定会发送ACK包给发送端。**

# 2.四次挥手如果客户端没收到服务器返回的close会一直等吗（不会），为什么

> TCP具有超时重传机制，当经过重发超时之后，客户端会重发FIN数据包，如果一直没有收到，会把重发超时按照2倍、4倍的指数规律进行重置，一直到重发指定次数，客户端认为服务器端出现了问题，强制关闭连接。

# 3.TCP是怎么保证可靠连接的
> TCP利用序列号（Seq）保证可靠连接，因为可靠连接要求识别数据是否已经接收，TCP会为每一个字节编一个号，这个就是Seq，接收端在收到数据之后，查询TCP首部中的序列号（Seq）以及数据长度，把自己下一步要接收的TCP数据段的第一个字节的序列号（Seq）放在确认应答的TCP首部发送给发送端。
>
> **Seq是TCP为每一个字节编的号，初始Seq由一个32位的时钟产生。**

**每个字节都有一个Seq，Seq存在于TCP首部，接收端下一步要接收的包的第一个字节的Seq放在ACK包的TCP首部发送给发送方。**

# 4.为什么需要三次握手

> 《计算机网络》中有提到，三次握手是为了避免某一个旧TCP连接的SYN包在网络中滞留了很久到达了服务端，这时服务端会向发送端发送ACK包，如果不需要客户端回复ACK包的话，服务器端就会以为TCP连接已经建立，会一直等待客户端发送数据，但是实际上客户端不会向服务器端发送数据，这就导致了服务器端资源的浪费。
>
> 本质在RFC793有说明，是因为TCP为了保证可靠连接使用了Seq，同时TCP可以使用最初的Seq确认是否是相同的连接，但初始的Seq是发送端自己凭借时钟生成的，所以为了保证可靠通信，TCP在接收到一个初始Seq（SYN包的TCP首部包含初始Seq）就会向客户端请求确认，只有客户端返回了ACK包，才能保证可靠连接。

# 5.为什么需要四次挥手
> 因为四次挥手过程中，客户端向服务器端发送FIN报文，服务器端在收到这个FIN报文，可能还有数据没有发完，所以不能把ACK和FIN报文合并发送，所以只能先向发送方发送ACK包，表示确认收到FIN包，等到数据处理完成，再发送FIN包，等待收到ACK包之后，服务器端就认为TCP连接已经关闭，进入CLOSE状态，客户端在等待一段时间之后自动进入CLOSE状态，至此TCP连接关闭。



# 6.HTTPS过程
1.HTTPS是加了SSL协议的HTTP，HTTPS需要先和SSL协议，SSL协议再和TCP协议通信。
2.HTTPS采用对称加密和非对称加密结合的方法，因为单一的对称加密不能保证密钥传输安全性，单一非对称加密计算消耗资源过大。
3.HTTPS会在传输密钥阶段使用非对称加密，在通信阶段使用对称加密。
4.HTTPS的过程
 - 服务器人员首先向CA申请公钥，CA在验证了申请者身份之后，会为申请者分配公钥并用自己的私钥对公钥做数字签名，然后把经过数字签名的公钥放到数字证书发给服务器端。
 - 客户端向服务器端请求通信时，服务器端会把数字证书发给客户端，客户端会利用CA的公钥对数字证书中的公钥数字签名做验证，如果验证通过，说明这是真实的服务器端公钥。
 - 客户端会使用这个公钥对对称加密要使用的密钥进行加密处理，并发送给服务前端。
 - 服务器端收到后会使用自己的私钥进行解密。
 - 开始通信，使用对称加密。


# 7.有哪些熟悉的HTTP状态码
> - 2XX状态码表示正常处理
>
>   1. 200状态码表示客户端的请求被正常处理了。
>
>   2. 204状态码，表示请求已经处理，但没有需要返回的报文主体部分。
>
>   3. 206状态码，表示范围请求已经正常处理。
> - 3XX状态码表示重定向
>   1. 301状态码，表示永久性重定向，当前客户端访问的资源已经被永久分配了新的URI，下次访问请使用新URI，会更新浏览器中的书签引用。
>   2. 302状态码，表示临时性重定向，当前客户端访问的资源临时被分配了新的URI，本次访问请使用新URI，但以后访问还是使用旧URI。
>   3. 304状态码，表示资源没有发生更改。
>   4. 307状态码，含义和302状态码一样，但因为302状态各浏览器都不遵循不能把POST改成GET的规定，所以重新定义的新状态码，对于307，所有浏览器都不会把POST改成GET。
> - 4XX状态码表示客户端错误
>   1. 400状态码，表示客户端请求报文中有语法错误。
>   2. 401状态码，表示需要身份验证。
>   3. 403状态码，表示客户端请求的资源不允许访问。
>   4. 404状态码，表示没有找到资源。
> - 5XX状态码表示服务器错误
>   1. 500状态码，表示服务器无法处理请求。
>   2. 503状态码，表示服务器正在停机维护或正超负载工作，无法响应请求。
>

# 8.OSI七层网络模型和TCP/IP五层网络模型

> - OSI七层网络模型
>   - OSI七层网络模型，从高到低是
>   - 应用层，作用是为应用程序提供服务。
>   - 表示层，数据格式转化、数据加密。
>   - 会话层，建立、管理和维护会话。
>   - 传输层，建立、管理和维护连接。
>   - 网络层，IP选址和路由选择。
>   - 数据链路层，提供链路管理。
>   - 物理层，通信所需的物理设施。
> - TCP/IP五层网络模型
>   - TCP/IP五层网络模型，从高到低是
>   - 应用层
>   - 传输层
>   - 网络层
>   - 数据链路层
>   - 物理层

# 9.TCP数据分片

> 因为TCP数据段需要在从发送端发给接收端，这样要求双方都需要有能力对TCP段进行处理，这就使得可能很大的TCP数据段需要切分。
>
> 在TCP握手的前2次握手中，TCP首部中会有MSS告知对方自己能接受的最大消息长度，实际通信所采用的MSS（最大消息长度）会采用较小的一个。
>
> **在TCP三次握手的时候完成。**

# 10.TCP滑动窗口

> 因为发送端在发送一个TCP段之后需要等待接收端的确认应答才能继续发送下一个数据段，这样就降低了通信性能，因此TCP引入了窗口的概念，窗口的大小是发送端一次能发送的TCP数据段的个数，如，窗口大小是3，发送端就可以连续发送3个TCP数据段，再等待接收端的确认应答。
>
> 如果发送端接受到一个确认应答，就会把窗口滑动到确认应答中的Seq位置。

# 11.窗口控制与重发机制

> 在进行滑动窗口的时候，如果发生丢包，发送端还是需要进行重发。
>
> - 触发重发机制的2种情况
>   - 接收端接收了TCP数据段，但是确认应答丢失。
>   - 接收端没有接收到TCP数据段。
>
> 1. **在第一种情况下**，发送端可以通过接收到后续确认应答来确定前面的一个TCP数据段已经被收到了，如，窗口的大小是3，如果发送端没有接收到第一个TCP数据段对应的确认应答，但是接收到了第二个TCP数据段对应的确认应答，这就说明第一个TCP数据段已经收到了，就不需要重发。
> 2. **在第二种情况下**，如果是某个TCP数据段丢失，那么接收端会会一直向发送端发送它想要接受的TCP数据段的第一个字节对应的Seq，如果发送端连续收到3次相同的确认应答，那么就会进行重发。

# 12.强缓存和协商缓存

> 强缓存和协商缓存是浏览器缓存策略，目的是为了降低请求时间。
>
> 强缓存是给资源设置一个过期时间，如果资源没有过期，浏览器就会使用强缓存，不会向浏览器发送请求。
>
> 强缓存可以通过响应报文的cache-control设置，cache-control : max-age = 604800，表示这个资源的有效期限是604800秒。在HTTP/1.0的情况下，cache-control会被忽略，这时候需要用到Expires响应头，使用Expires: Wed, 04 Jul 2021 08:26:05 GMT来设置资源过期时间，超过这个时间之后，资源就过期了。**在Expires和cache-control同时存在的时候，cache-control优先级更高。**
>
> 当浏览器想要请求一个资源，并且发现这个资源的有效期已经到期，那么就会触发协商缓存，浏览器会将上次资源的响应头中取出E-tag和last-modified字段，并把E-tag放入请求头If-None-Match，把last-modified放入If-Modified-Since请求头，如果服务器返回304 Not Modified，那么浏览器就会使用缓存，如果服务器返回200 OK，那么浏览器就会使用服务器返回的资源。

# 13.SSL握手的过程

> SSL过程有4次握手，来建立SSL连接，保证HTTP连接的安全性。
>
> 1. 第一次握手
>    - 客户端发送Client Hello，以及客户端支持的SSL版本，客户端支持的加密算法和密钥长度。
> 2. 第二次握手
>    - 服务器端回复Sever Hello，以及从客户端支持的加密算法和密钥长度中筛选出来的加密算法和密钥长度。
>    - 服务器发送Certificate报文，报文中包含公钥证书。
>    - 服务端发送Server Hello done报文。
> 3. 第三次握手
>    - 客户端发送Client Key Exchange作为回应，其中包含一个随机密码串，这个密码串已经使用公钥加密。
>    - 客户端发送Change Cipher Spec报文，这个报文会提示服务器端之后的通信使用刚刚发送的密码串加密。
>    - 客户端发送Finished报文，报文中包含本次握手的整体校验值，如果服务器端可以正确解密，那么握手成功。
> 4. 第四次握手
>    - 服务器端发送Change Cipher Spec报文。
>    - 服务器端发送Finished报文。

# 14.DNS域名解析的过程

> DNS域名解析是指由于IP地址并不好记，所以为了方便记忆开发出了方便人记忆的域名系统，但是因为计算机需要IP地址，所以在浏览器收到对一个域名的访问的时候，会先进行DNS查询，把域名转换为对应IP地址。
>
> **DNS协议位于应用层。**
>
> 1. 首先浏览器会在操作系统的hosts文件中查找，是否有缓存的域名和IP地址的映射。
> 2. 如果本地没有找到，那么会去向本地DNS服务器进行查询（本地DNS服务器一般由网络运营商提供），一般百分之八十的DNS请求都会在本地域名服务器找到对应IP的缓存。
> 3. 如果本地域名服务器也没有找到，那么本地域名服务器就会去向根域名服务器进行查询，根域名服务器不会直接返回域名的对应IP地址，根域名服务器会返回对应顶级域名服务器的地址。
> 4. 本地域名服务器再去对应顶级域名服务器查找，顶级域名服务器也不会直接返回域名对应的IP，顶级域名服务器会返回该域名的注册域名服务器的地址。
> 5. 本地域名服务器再去向该域名的注册域名服务器地址进行查询，然后会收到对应的IP地址。

# 15.DNS基于哪种协议

> DNS主要基于UDP协议。
>
> - 因为UDP协议是面向无连接的协议，不需要经过TCP三次握手，这样网络性能更高，且服务器负载更小，而且域名查询的包一般都很小，不会超过512字节，所以可以使用UDP。
>
> DNS在2种情况下，也会使用TCP协议
> 1. 当本地域名服务器收到的查询response的字节数超过512字节的时候，本地域名服务器会进行重发，并使用TCP。
> 2. DNS在进行区域传输的时候使用TCP。因为区域传输一般用于同步主DNS服务器和辅助DNS服务器的内容，所以包一般会比较大，所以使用TCP协议。

# 16.DNS区域传输

> 为了降低DNS服务器的压力，DNS域名空间被分成区域进行管理，每个区域可以由多台DNS服务器进行管理（一台主DNS服务器，多台辅助DNS服务器）。辅助DNS服务器储存着主DNS服务器的数据副本，每3个小时会进行一次同步。

# 17.TCP流量控制

> TCP流量控制是为了解决窗口过大，发送端发送的数据量超过了接受端的接收能力的问题。
>
> TCP流量控制可以在传输过程中动态改变窗口的大小，接收端会向发送端发送自己的缓存区的剩余大小，发送端会根据这个数据动态改变窗口大小。
>
> 当缓存区已满的情况下，发送端会停止发送数据，等到收到接收端的窗口大小更新通知之后再开始发送数据，同时为了防止窗口大小更新数据丢包，发送端会每隔一段时间向接收端发送一个字节大小的窗口大小探测数据段。

# 18.TCP的拥塞控制

> 因为窗口协议允许发送端一次发送大量数据，但是如果网络正处于拥堵状态，突然发送大量数据会使得网络瘫痪，所以TCP引入了慢启动机制。
>
> - 慢启动机制
>
>   - 慢启动机制是指在最开始将滑动窗口大小置为1个MSS大小，当发送端成功接收1个确认应答之后，将窗口大小增加1个MSS。（这个拥塞窗口和流量控制相适应，会选取拥塞窗口和流量控制中较小的一个）。
>
> - 慢启动阈值
>
>   - 当发送端不断收到确认应答，拥塞窗口的大小也会快速增加，所以TCP又引入了慢启动阈值，当拥塞窗口大小超过慢启动阈值，那么每次增加只能按照公式一点点增加
>
>     1个数据段字节数/拥塞窗口字节数 * 一个数据段字节数
>
>   - 慢启动阈值在一开始是没有被设置的，只有在碰到重发超时或高速重传的时候才会被设置。
>
>   - 当遇到超时重发的时候，拥塞窗口会被重置为1个数据段大小，慢启动阈值会被设置为当时拥塞窗口的一半大小。
>
>   - 当遇到高速重传的时候，慢启动阈值会被设置为当前拥塞窗口的一半，拥塞窗口会被重置为慢启动阈值的大小加3个数据段大小。
>
> - 快恢复
>
>   - 快恢复就是当拥塞控制遇到高速重传的时候，拥塞窗口不会被置为1个数据段大小，而是被置为慢启动阈值加3个数据段大小。

